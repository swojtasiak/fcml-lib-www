<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Free Code Manipulation Library site.">
    <meta name="author" content="Sławomir Wojtasiak">
	<meta name="keywords" content="assembler, disassembler, dynamic library, static library, parser, renderer, generic instruction model, load-and-go assembler, multi-pass assembler, FCML, Intel, AT&amp;T, MMX, 3D-Now!, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, SSE4A, AVX, AVX2, AES, TBM, BMI1, BMI2, HLE, ADX, CLMUL, RDRAND, RDSEED, FMA, FMA4, LWP, SVM, XOP, VMX, SMX">
    <link rel="shortcut icon" href="assets/ico/favicon.ico">
    <title>Manual - Free Code Manipulation Library</title>
	<!-- Code Highlighter -->
	<link href="css/sh/shCore.css" rel="stylesheet" type="text/css" />
	<link href="css/sh/shThemeEclipse.css" rel="stylesheet" type="text/css" />
    <!-- Bootstrap core CSS -->
    <link href="css/fcml.css" rel="stylesheet">
    <!-- Just for debugging purposes. Don't actually copy this line! -->
    <!--[if lt IE 9]><script src="js/ie8-responsive-file-warning.js"></script><![endif]-->
    <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
      <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body data-spy="scroll" data-target=".toc-sidebar" class="num_headings">
  
	<a href="#main" class="sr-only">Skip to main content</a>
	<div class="github-fork-ribbon-wrapper right fixed" style="width: 150px;height: 150px;position: fixed;overflow: hidden;top: 50px;z-index: 9999;right: 0;"><a href="https://github.com/swojtasiak/fcml-lib"><img width="149" height="149" src="https://github.blog/wp-content/uploads/2008/12/forkme_right_darkblue_121621.png?resize=149%2C149" class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a></div>
	
	<!-- Header -->
     <header class="navbar navbar-inverse navbar-fixed-top header-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="index.html">FCML</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav navbar-right">
            <li><a href="index.html">Home</a></li>
            <li><a href="manual.html#quick_start">Quick Start</a></li>
            <li><a href="manual.html">Manual</a></li>
			<li><a href="api/globals.html">API</a></li>
			<li><a href="changelog.html">Changelog</a></li>
			<li><a href="download.html">Download</a></li>
			<li><a href="contact.html">Contact</a></li>
			<li><a href="https://github.com/swojtasiak/fcml-lib">GitHub</a></li>
          </ul>
        </div>
      </div>
    </header>
	
	<!-- Content -->
	<article class="container"  >
	
		<div class="row">
	
			<div class="col-sm-9">
	
<!-- *********************** -->			   
<!-- Static table of content -->
<!-- *********************** -->

				<p class="manual-title">The FCML Library Reference Manual</p>
				<p>(The manual does not cover AVX-512 yet.)</p>
				<p>
					<b>Authors:</b><br>
					<span class="authors-box" id="author-sw">Sławomir Wojtasiak</span><br>
					<span class="copyright-element">
						Copyright &copy; 2014-2020 Sławomir Wojtasiak. All Rights Reserved.
					</span>
				</p>
				
			   <p class="manual-toc">Table of Contents</p>
			   
				<ul id="top-table-of-content" class="static-toc toc-numbered" >
					<li><a href="#what_is">What is FCML</a></li>
					<li><a href="#features">Features</a></li>
					<li><a href="#license">License</a></li>
					<li><a href="#installation">Installation</a>
						<ul>
							<li><a href="#installation-downloading">Downloading</a></li>
							<li><a href="#installation-gnu_linux">GNU/Linux</a></li>
							<li><a href="#installation-windows">Windows</a>
								<ul>
									<li><a href="#installation-windows-mingw">MinGW</a></li>
									<li><a href="#installation-windows-vs">Visual Studio</a></li>
								</ul>	
							</li>
						</ul>
					</li>
					<li><a href="#quick_start">Quick Start</a>
						<ul>
							<li><a href="#quick_start-assembler">Assembler</a></li>
							<li><a href="#quick_start-disassembler">Disassembler</a></li>
						</ul>
					</li>
					<li><a href="#manual">Manual</a>
						<ul>
							<li><a href="#generic_instruction_model">Generic instruction model</a>
								<ul>
									<li><a href="#prefixes">Prefixes</a></li>
									<li><a href="#instruction_level_hints">Instruction level hints</a></li>
									<li><a href="#mnemonic">Mnemonic</a></li>
									<li><a href="#conditional_instructions">Conditional instructions</a></li>
									<li><a href="#operands">Operands</a>
										<ul>
											<li><a href="#op-hints">Hints</a></li>
											<li><a href="#op-immediate">Immediate value operand</a></li>
											<li><a href="#op-far-pointer">Far pointer operand</a></li>
											<li><a href="#op-address-operand">Address operand</a></li>
											<li><a href="#op-register-operand">Register operand</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#un-entry-point">Understanding entry point</a></li>
							<li><a href="#dialects">Dialects</a>
								<ul>
									<li><a href="#dialects-initializing-intel">Initializing Intel dialect</a></li>
									<li><a href="#dialects-initializing-gas">Initializing AT&amp;T (GAS) dialect</a></li>
									<li><a href="#dialects-disposing">Disposing dialect</a></li>
									<li><a href="#dialects-differences">Important differences between dialects</a>
										<ul>
											<li><a href="#dialects-difs-far-pointers">Far pointers</a></li>
											<li><a href="#dialects-difs-relative-addresses">Relative addresses</a></li>
											<li><a href="#dialects-dir-ind-addresses">Direct and indirect addresses</a>
												<ul>
													<li><a href="#dialects-dir-ind-addresses-intel">Intel dialect</a></li>
													<li><a href="#dialects-dir-ind-addresses-gas">AT&amp;T dialect</a></li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#data-types">Data types</a></li>
							<li><a href="#error-handling">Error handling</a></li>
							<li><a href="#configuring-environment">Configuring environment</a></li>
							<li><a href="#pseudo-operations">Pseudo operations</a></li>
							<li><a href="#symbols">Symbols</a></li>
							<li><a href="#assembler">Assembler</a>
								<ul>
									<li><a href="#assembler-initialization">Initializing assembler instance</a></li>
									<li><a href="#assembler-assembling">Assembling generic instruction model</a>
										<ul>
											<li><a href="#asm-ctx">Assembler context</a></li>
											<li><a href="#asm-optimizers">Optimizers</a></li>
											<li><a href="#asm-choosers">Instruction choosers</a></li>
											<li><a href="#asm-result">Preparing assembler result</a></li>
											<li><a href="#asm-invoke">Invoking assembler</a></li>
										</ul>
									</li>
									<li><a href="#assembler-multi-pass">Multi pass assembler</a></li>
								</ul>
							</li>
							<li><a href="#parser">Parser</a>
								<ul>
									<li><a href="#parser-init-invoke">Initialization and parsing</a></li>
									<li><a href="#parser-how-it-works">How parser works</a></li>
									<li><a href="#parser-common-rules">Common rules</a>
										<ul>
											<li><a href="#parser-common-numeric">Representation of numeric values</a></li>
											<li><a href="#parser-common-expressions">Expressions handling</a></li>
										</ul>
									</li>
									<li><a href="#parser-intel">Intel parser</a>
										<ul>
											<li><a href="#parser-intel-numeric">Numeric values</a></li>
											<li><a href="#parser-intel-registers-expressions">Registers</a></li>
											<li><a href="#parser-intel-size-operators">Size operators</a></li>
											<li><a href="#parser-intel-prefixes">Prefixes</a></li>
											<li><a href="#parser-intel-hints">Hints</a></li>
										</ul>
									</li>
									<li><a href="#parser-gas">AT&amp;T parser</a>
										<ul>
											<li><a href="#parser-gas-numeric">Numeric values</a></li>
											<li><a href="#parser-gas-registers-expressions">Registers</a></li>
											<li><a href="#parser-gas-size-operators">Size operators</a></li>
											<li><a href="#parser-gas-prefixes">Prefixes</a></li>
											<li><a href="#parser-gas-hints">Hints</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#disassembler">Disassembler</a>
								<ul>
									<li><a href="#disassembler-init">Initializing disassembler instance</a></li>
									<li><a href="#disassembler-result">Initializing disassembler result</a></li>
									<li><a href="#disassembler-disassembling">Disassembling machine code</a></li>
									<li><a href="#disassembler-analyse">Analysing instruction details</a>
										<ul>
											<li><a href="#disassembler-analyse-shortcuts">Shortcuts</a></li>
											<li><a href="#disassembler-analyse-machine-code">Instruction machine code</a></li>
											<li><a href="#disassembler-analyse-prefixes">Prefixes</a></li>
											<li><a href="#disassembler-analyse-operand-details">Operand details</a></li>
											<li><a href="#disassembler-analyse-modrm">Details about ModR/M field</a></li>
											<li><a href="#disassembler-analyse-fields">Instruction code and opcode fields</a></li>
											<li><a href="#disassembler-instruction-groups">Instruction groups</a></li>
										</ul>
									</li>
									<li><a href="#disassembler-free">Freeing resources</a></li>
								</ul>
							</li>
							<li><a href="#instruction-renderer">Instruction renderer</a></li>
						</ul>
					</li>
					<li><a href="#cpp-wrapper">CPP Wrapper</a>
						<ul>
							<li><a href="#cpp-mnemonics">Mnemonics</a></li>
							<li><a href="#cpp-common-types">Common types</a>
								<ul>
									<li><a href="#cpp-common-types-cpp-character-types">Character types</a></li>
									<li><a href="#cpp-common-types-cpp-entry-point-class">EntryPoint class</a></li>
									<li><a href="#cpp-common-types-cpp-integer-class">Integer class</a></li>
									<li><a href="#cpp-common-types-cpp-register-class">Register class</a></li>
								</ul>
							</li>
							<li><a href="#cpp-generic-instruction-model">Generic instruction model</a>
								<ul>
									<li><a href="#cpp-generic-instruction-model-cpp-far-pointer">Far pointer</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-segment-selector">Segment selector</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-effective-address">Effective address</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-addresses">Addresses</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-conditions">Conditions</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-operands">Operands</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-instructions">Instructions</a></li>
								</ul>
							</li>
							<li><a href="#cpp-assembler">Assembler</a></li>
							<li><a href="#cpp-multiline-assembler">Multiline assembler</a></li>
							<li><a href="#cpp-stateful-assembler">Stateful assembler</a></li>
							<li><a href="#cpp-disassembler">Disassembler</a></li>
							<li><a href="#cpp-stateful-disassembler">Stateful disassembler</a></li>
						</ul>
					</li>
					<li><a href="#example">Examples</a>
						<ul>
							<li><a href="#examples-fcml-asm">fcml-asm</a></li>
							<li><a href="#examples-fcml-disasm">fcml-disasm</a></li>
							<li><a href="#examples-hsdis">hdis</a></li>
						</ul>
					</li>
				</ul>


<!-- ****** -->			   
<!-- MANUAL -->
<!-- ****** -->
	
<h1 id="what_is">What is FCML</h1>
<p>
	FCML is an acronym for Free Code Manipulation Library. This is a general purpose machine code manipulation library for IA-32 and Intel 64 architectures. The library supports UNIX-like systems as well as Windows and is highly portable. The FCML library is free for commercial and non-commercial use as long as the terms of the LGPL license are met. Currently it supports such features as:
</p>

<h1 id="features">Features</h1>
<p>All major features supported by the FCML library:</p>
<ul class="feature-list">
	<li>A one-line disassembler</li>
	<li>A one-line assembler</li>
	<li>An experimental multi-pass load-and-go assembler (Multi line!)</li>
	<li>Support for Intel and AT&amp;T syntax</li>
	<li>Instruction parsers</li>
	<li>Instruction renderers</li>
	<li>Instructions represented as generic models</li>
	<li>UNIX/GNU/Linux and Windows (mingw, mingw64, cygwin, VS2017, VS2019) support</li>
	<li>Portable - written entirely in C (no external dependencies)</li>
	<li>C++ wrapper available</li>
	<li>Supported instruction sets: <span class="instruction-list">MMX, 3D-Now!, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, SSE4A, AVX, AVX2, AES, TBM, BMI1, BMI2, HLE, ADX, CLMUL, RDRAND, RDSEED, FMA, FMA4, LWP, SVM, XOP, VMX, SMX, AVX-512, XEON PHI</span></li>
</ul>
	
<h1 id="license">License</h1>
<p>FCML (Free Code Manipulation Library).</p>
<p>Copyright (C) 2010-2020 Sławomir Wojtasiak</p>
<p>This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.</p>
<p>This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public</p>
<p>License along with this library; if not, write to the Free Software</p>
<p>Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA</p>

<h1 id="installation">Installation</h1>
<p>The following chapters explain how to download and install FCML under GNU/Linux and Windows systems.</p>
<h2 id="installation-downloading">Downloading</h2>
	Follows this link <a href="download.html">Download</a> in order to download the current FCML distribution package. The distribution package contains source code and predefines binaries for windows.
<h2 id="installation-gnu_linux">GNU/Linux</h2>
<p>FCML uses autotools, so its installing process is standardized and follows all autotools rules. Consequently everything you have to do is to execute the following commands:</p>
<pre>
./configure
make &amp;&amp; make install
</pre>
<p>Then, in order to check if everything works you should also execute unit tests using the following command:</p>
<pre>make check</pre>
<p>It should return a test execution report, like this one:</p>
<pre>
Test [Internal unit tests]: 
Run Summary:      Type         Ran     Passed     Failed 
                suites          13         13          0 
                 tests         184        184          0 
               asserts        1772       1772          0 
PASS: fcml_internal_check 
============= 
1 test passed 
============= 
…
Test [Public API tests]: 
Run Summary:      Type         Ran     Passed     Failed 
                suites          28         28          0 
                 tests         610        610          0 
               asserts        8096       8096          0 
PASS: fcml_public_check 
============= 
1 test passed 
============= 
</pre>
<p>FCML does not have any external dependencies and as such the build process is quite straightforward and is very unlikely to fail. Anyway, if needed you can customize the build process by adding additional options to the configure script. For instance, in order to build only the static library, you can disable the shared one by adding --disable-shared option as follows:
</p>
<pre>
./configure --disable-shared
</pre>
<p>Use --help parameter in order to display all available configuration options. Do not hesitate to read <a href="http://sourceforge.net/p/fcml/code/ci/master/tree/INSTALL">INSTALL</a> file in the distribution archive, which describes installation process in every details.</p>
<p>If you have Doxygen installed the API documentation will be also generated.</p>

<h2 id="installation-windows">Windows</h2>
Building Windows binaries is a bit more complicated and it is why there are dedicated archives with pre-built libraries. 

<h3 id="installation-windows-mingw">MinGW</h3>

<p>
In case of MinGW the build process is quite straightforward as long as we do not want to build a library with undecorated symbol names. In such a case the configure script should be used the same way as in the case of UNIX-like systems. For instance: 
</p>
<pre>
./configure
make &amp;&amp; make install
</pre>
<p>Remember that such libraries are not compatible with Visual Studio, because Visual Studio uses <a href="http://www.transmissionzero.co.uk/computing/advanced-mingw-dll-topics/">different symbol decorations</a>. Of course you can generate undecorated symbols using the MinGW tools chain, but it is a bit more advanced task and it is out of scope of this manual (see dlltool and module definition files).</p>
<p>If you would like to build binaries for x86_64 architecture you have to install <a href="http://mingw-w64.sourceforge.net/">mingw-w64</a> and then set the appropriate host running the configure script:</p>
<pre>
$ ./configure <b>--host=x86_64-w64-mingw32</b>
…
***************************************************
fcml version 1.0.0 
Host CPU.........: <b>x86_64</b> 
Host OS:.........: mingw32 
Prefix:..........: /usr/local 
Debug Build......: no 
Shared Library...: yes 
Compiler.........: x86_64-w64-mingw32-gcc -std=gnu99 -g -O2 
Linker...........: C:/mingw64/x86_64-w64-mingw32/bin/ld.exe 
Doxygen..........: NONE 
***************************************************
</pre>
<p>In the report "Host CPU" should point to the appropriate CPU architecture.</p>
<p>If you have Doxygen installed the API documentation will also be generated. As you could see in the example above Doxygen was not found.</p>

<h3 id="installation-windows-vs">Visual Studio</h3>
<p>
	There are solutions prepared for Visual Studio available in <i>win32/vs2008</i>, <i>win32/vs2010</i> and <i>win32/vs2013</i> directories. Everything you need to do is to load such a solution using your Visual Studio and click build. All paths are relative to the distribution directory so everything should be built without any problems. You can also choose between a few configurations in order to build static or dynamic libraries. Solutions supports x86 and x64 builds.
<p> 
<p>
	Remember that header files available in <i>${DIST_DIR}/include</i> have to be added as include directory to the destination project in order to use the built libraries.
</p> 
<p>
	Visual Studio Express is fully supported, so if you do not have access to the full version, you can build the library using the express version.
</p>

<h1 id="quick_start">Quick Guide</h1>
<p>
	The following chapters show how to assemble and disassemble instructions with as little effort as possible without digging in every detail and function supported by the library. These chapters are completely independent, so if you are interested only in disassembling feel free to read only the disassembler section.
</p>
<p>
	You will need a working FCML binaries, therefore if you do not have any you should head over to the following chapter first: <a href="#installation">Installing FCML.</a>
</p> 

<!--- *** ASSEMBLER *** --->

<h2 id="quick_start-assembler">Assembler</h2>
<p>
	The FCML assembler allows us to assemble instructions encoded in a <a href="#generic_instruction_model">generic instruction model</a> (called GIM in the next sections) prepared by the user or returned as a result of the instruction parsing process. Therefore the first thing is the GIM. For the purpose of this chapter we will prepare it on our own, but you can also convert a textual instruction to a GIM instance using FCML parsers (see: <a href="#parser">Parser</a> for more details about parsing).
</p>
<p>
	So for instance the GIM for a simple instruction: "<span class="instruction">adc ax, 0x8042</span>" can be encoded as follows:
</p>

<pre class="brush: cpp">
#include &lt;fcml_common.h&gt;

fcml_st_instruction instruction = {0};
instruction.mnemonic = "adc";
instruction.operands[0] = FCML_REG( fcml_reg_AX );
instruction.operands[1] = FCML_IMM16( 0x8042 );
instruction.operands_count = 2;
</pre>
<p>
	The structure <i>fcml_st_instruction</i> is defined in the <i><a href="api/fcml__common_8h.html">fcml_common.h</a></i> header file. It is the main structure of the GIM model. Utility macros <i>FCML_REG</i> and <i>FCML_IMM16</i> are defined in the <i><a href="api/fcml__common__utils_8h.html">fcml_common_utils.h</a></i> header file and can be used just to make source code shorter. See the page <a href="api/globals.html">API</a> where all utility macros and functions are described. 
</p>
<p>
	The second line allocates space for the instruction model. In the third line we specify an instruction by its mnemonic (remember that mnemonic is dialect dependant). Line four defines a register operand with one AX general purpose register. Line five sets the second operand to 16-bit unsigned immediate value and in the last line, the number of used operands is specified. 
<p>
<p>
	Now when the GIM is ready it is time to prepare the assembler which will be able to assemble the model. In order to initialize the assembler an initialized dialect instance is needed. Thanks to the dialects the library is able to use different instruction syntaxes like the Intel or AT&amp;T. So let's prepare an instance of the Intel dialect:
</p>
<pre class="brush: cpp">
#include &lt;fcml_intel_dialect.h&gt;

fcml_st_dialect *dialect;
fcml_ceh_error error = fcml_fn_dialect_init_intel( FCML_INTEL_DIALECT_CF_DEFAULT, &amp;dialect );
if( error ) {
	printf( "Cannot initialize the Intel dialect, error: %d\n", error );
	exit(EXIT_FAILURE);
}
</pre>
<p>
	As you can see there are dedicated functions to create different dialects. Every function can also take additional parameters used to configure the initialized dialect instance. In theory it should be possible to implement every existing dialect for FCML but currently only the Intel and AT&amp;T (called GAS) dialects are supported. For the sake of the example the Intel dialect (the preferred one) is used. 
</p>
<p>
	The dialect is ready, so let's initialize the assembler using the <i><a href="api/fcml__assembler_8h.html#ae8182220144272c8f233b7782da76a3c">fcml_fn_assembler_init</a></i> function:
</p>

<pre class="brush: cpp">
fcml_st_assembler *assembler;
error = fcml_fn_assembler_init( dialect, &amp;assembler );
</pre>

<p>
	To make the code a bit clearer error handling has been avoided in this specific case, but it should be implemented in the same way as in the case of dialect initialization. All possible error codes are defined in the <i><a href="api/fcml__errors_8h.html">fcml_errors.h</a></i> header file.
</p>
<p>
	Once both the dialect and the assembler are initialized, there is the last thing to be done before assembling is possible. It is an assembler result structure. This structure is reusable, therefore it has to be prepared in the right way in order to allow assembler to reuse it correctly. To do so, a manually allocated structure has to be passed to the <i><a href="api/fcml__assembler_8h.html#a3a827d482043c2fc1c6766e71f047484">fcml_sn_assembler_result_prepare</a></i> function:
</p>

<pre class="brush: cpp">
fcml_st_assembler_result asm_result;
fcml_fn_assembler_result_prepare( &amp;asm_result );
</pre>

<p>
	Notice that we have not used the partial initialization to clear the memory held by the allocated structure this time. We could omit it because it is the mentioned function that clears the structure for us. 
</p>
<p>
	That is all, assembler is prepared to do its job, so let's try to assemble the model from the example above.
</p>
<p>
	The main structure that has to be properly prepared for the assembler to work is <i><a href="api/fcml__assembler_8h.html#ac72d9fd39163fe6cabf8c2e87e64bae7">fcml_st_assembler_context</a></i>. It consists of the previously initialized assembler instance which should be used to assemble machine code, some configuration flags we can use to configure assembling process and an <a href="#un-entry-point">entry point</a> which will be used to inform the assembler about the code segment the instruction is destined for. The assembler context itself can be initialized on the stack but it is very important to clear memory it uses before passing it to the assembler. We should do it just to set all configuration options and other parameters to their default values. For example the following source code shows the proper way to initialize the assembler context: 
</p>

<pre class="brush: cpp">
fcml_st_assembler_context context = {0};
</pre>

<p>Having the context set up, we should provide an assembler instance first:</p>

<pre class="brush: cpp">
context.assembler = assembler;
</pre>

<p>
	Now it is time to set the configuration flags. For beginners the most useful option is called <i><a href="api/structfcml__st__assembler__conf.html#a9848f423218cd1c2ad600575e8c723da">enable_error_messages</a></i>. It is used to enable support for textual error messages, which can be very useful when an error occurs, so let's set it to true: 
</p>

<pre class="brush: cpp">
context.configuration.enable_error_messages = FCML_TRUE;
</pre>
<p>
	As you noticed without any doubt we have used a strange constant <i>FCML_TRUE</i> in place of "true" for the boolean variable. This constant is defined inside the <i><a href="api/fcml__types_8h.html">fcml_types.h</a></i> header file and should be used whenever true (<i>FCML_TRUE</i>) or false (<i>FCML_FALSE</i>) should be directly set for given variable, but of course every not zero value can be used in case of true. 
</p>
<p>
	There is one more configuration option which can be interesting now, it is <i><a href="api/structfcml__st__assembler__conf.html#a954159936ace6f452ae9f6727ea2bfb5">increment_ip</a></i> but we will describe it later.
</p>
<p>
	The last thing to do is to set up the entry point correctly:
</p>
<pre class="brush: cpp">
context.entry_point.addr_form = FCML_MO_32_BIT;
context.entry_point.ip = 0x401000;
</pre>
<p>
	As you can see, processor operating mode has been set to 32 bits and EIP register to 0x401000 which is the default address for many assemblers/compilers. We have not set the operand size attribute or address size attribute so they both are set to their default values, which are 32 bits for both of them in case of the chosen processor operating mode.
</p>
<p>
The full source code for initializing the assembler context:
</p>
<pre class="brush: cpp">
fcml_st_assembler_context context = {0};
context.assembler = assembler;
context.configuration.enable_error_messages = FCML_TRUE;
context.entry_point.addr_form = FCML_OM_32_BIT;
context.entry_point.ip = 0x401000;
</pre>
<p>Now we are ready to assemble the GIM we prepared earlier, so let's do that.</p>
<p>
In order to assemble an instruction model, we have to use <i>fcml_fn_assemble</i> function defined by
<i>fcml_assembler.h</i> header file. This is the definition of the function:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_assemble( 
	fcml_st_assembler_context *context, 
	const fcml_st_instruction *instruction, 
	fcml_st_assembler_result *result );
</pre>
<p>We have everything we need to fill its arguments. The following code shows how to invoke the
function with structures we have already prepared:</p>
<pre class="brush: cpp">
error = fcml_fn_assemble( &amp;context, &amp;instruction, &amp;asm_result );
if( error ) {
    ...
}
</pre>
<p>
If everything succeeded, the <i>error</i> variable is set to <i><a href="api/group__ERRORS__GROUP.html#ga88406cc59b708d9f4de9286d254dd10a">FCML_CEH_GEC_NO_ERROR</a></i> and <i>asm_result</i> contains the assembled machine code.
</p>
<p>Let's take a look at <i><a href="api/structfcml__st__assembler__result.html">fcml_st_assembler_result</a></i> structure. The field <i>errors</i> contains textual error messages if
function failed. Assembled instructions are stored as a chain of <i><a href="api/structfcml__st__assembled__instruction.html">fcml_st_assembled_instruction</a></i> structures. 
A chain was used, because there are instructions that can be assembled to more than one form. For example some of 
them can be assembled to even three different pieces of machine code. It is why the chain is just convenient here. Fortunately you do not have
to analyse all available forms in order to identify the best one considering your processor operating mode, size attributes,
etc. The most relevant piece of machine code is chosen by the assembler and is returned in <i>chosen_instruction</i> field. The last field
<i>number_of_instructions</i> contains number of instruction forms available in the chain. Although it
can be calculated going through all instructions in the chain, it is needed rather frequently so it is
better to have it on hand.
</p>
<p>
The structure <i><a href="api/structfcml__st__assembled__instruction.html">fcml_st_assembled_instruction</a></i> holds information related to one assembled instruction and can contain optional
warning messages if the instruction was assembled correctly, but FCML assembler had
some objections to the generated machine code. The assembled machine code as a pointer to an array of bytes is
available through the field <i>code</i> and the array length is stored in <i>code_length</i> field.
</p>
<p>
As you may remember I pointed out that <i><a href="api/structfcml__st__assembler__result.html">fcml_st_assembler_result</a></i> structure is reusable and as so
the same structure can be used for every invocation of <i><a href="api/fcml__assembler_8h.html#a232c49ae5936be24d990a5a012a63e78">fcml_fn_assemble</a></i> function. It is very
convenient, because we do not need to allocate and free this structure for every instruction being
assembled. It is the assembler which is responsible for freeing everything that assembler result
contains like generated machine code or warning messages and reusing it.
</p>
<p>
When we are speaking about assembling multiple instructions one by one and reusing some
assembler parameters, it is time to point out configuration flag <i>increment_ip</i> mentioned earlier. This
flag can be used in order to force the assembler to increase the instruction pointer using the length
of the chosen instruction (Length of the machine code generated for it to be more specific.) after every successful invocation of the assembler. It is very convenient if
we assemble instructions that follows each other in the code segment, because we do not need to
calculate the instruction pointer for them every time.
</p>
<p>
When the whole machine code is ready and there is nothing more to assemble, we should free all resources
that are not needed any more. The first structure we have to free is <i><a href="api/structfcml__st__assembler__result.html">fcml_st_assembler_result</a></i>, because even if it is
allocated on the stack it might still contain the assembled machine code and potential warning messages. You should call
<i><a href="api/fcml__assembler_8h.html#af7c11065d9016903daf8ae0a3b1d4d74">fcml_fn_assembler_result_free</a></i> in order to free this information. Take into account that this function will
not free the structure itself, so memory used by it has to be freed anyway or the structure can be still
reused by another invocation of the assembler (Remember that you are owner of the structure and that you are responsible for freeing it at some point.)
</p>
<pre class="brush: cpp">
fcml_fn_assembler_result_free( &amp;asm_result );
</pre>
<p>We should also free the assembler itself and the dialect:</p>
<pre class="brush: cpp">
fcml_fn_assembler_free( assembler );
fcml_fn_dialect_free( dialect );
</pre>
<p>Remember that dialect has to be freed after the assembler.</p>
<p>The following source code assembles the generic instruction model from the example above:</p>
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;fcml/fcml_intel_dialect.h&gt;
#include &lt;fcml/fcml_assembler.h&gt;
#include &lt;fcml/fcml_common_utils.h&gt;

int main(int argc, char **argv) {

	fcml_ceh_error error;

	/* Initializes the Intel dialect instance. */
	fcml_st_dialect *dialect;
	if( ( error = fcml_fn_dialect_init_intel( FCML_INTEL_DIALECT_CF_DEFAULT, &amp;dialect ) ) ) {
		fprintf( stderr, "Can not initialize Intel dialect: %d\n", error );
		exit(1);
	}

	fcml_st_assembler *assembler;
	if( ( error = fcml_fn_assembler_init( dialect, &amp;assembler ) ) ) {
		fprintf( stderr, "Can not initialize assembler: %d\n", error );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	fcml_st_instruction instruction = {0};
	instruction.mnemonic = "adc";
	instruction.operands[0] = FCML_REG( fcml_reg_AX );
	instruction.operands[1] = FCML_IMM16( 0x8042 );
	instruction.operands_count = 2;

	/* Prepares the result. */
	fcml_st_assembler_result asm_result;
	fcml_fn_assembler_result_prepare( &amp;asm_result );

	fcml_st_assembler_context context = {0};
	context.assembler = assembler;
	context.entry_point.ip = 0x401000;
	context.entry_point.op_mode = FCML_OM_32_BIT;

	/* Assembles the given instruction. */
	if( ( error = fcml_fn_assemble( &amp;context, &amp;instruction, &amp;asm_result ) ) ) {
		fprintf( stderr, "Can not assemble instruction: %d\n", error );
		fcml_fn_assembler_free( assembler );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	/* Prints the instruction code. */
	if( asm_result.chosen_instruction ) {
		fcml_st_assembled_instruction *ins_code = asm_result.chosen_instruction;
		int i;
		printf("Chosen instruction code: ");
		for( i = 0; i &lt; ins_code-&gt;code_length; i++ ) {
			printf("%2x", ins_code->code[i]);
		}
		printf("\n");
	} else {
		fprintf( stderr, "Hmm, where is the assembled instruction?\n" );
	}

	fcml_fn_assembler_result_free( &amp;asm_result );
	fcml_fn_assembler_free( assembler );
	fcml_fn_dialect_free( dialect );

	return 0;
}
</pre>
<div class="notice-box">As you might have noticed, we have used a bit different location for the header files. In the examples above we firstly supposed that header files are placed directly in the include directory, but in the case of the last example files are located in the dedicated "fcml" directory. It depends on the configuration. By default in case of GNU/Linux and MinGW include files are installed in the dedicated subdirectory, but it can be changed. Just head over to the INSTALL file available in the distribution archive in order to investigate the subject in great depth.</div>
<p>The example should prints the following result:</p>
<pre>
Chosen instruction code: 66154280
</pre>

<!--- *** DISASSEMBLER *** --->

<h2 id="quick_start-disassembler">Disassembler</h2>
<p>FCML disassembler takes a piece of machine code as an argument and "converts" it to a GIM instance (see: <a href="#generic_instruction_model">Generic
instruction model</a>) which contains all information about the disassembled instruction. Such
GIM can be used directly or for example can be rendered to the textual form of the instruction.
</p>
<p>The first thing we have to do is to initialize a dialect which will be used by the disassembler to
disassemble the provided machine code. Thanks to the dialects the library is able to use different instruction
syntaxes like Intel or AT&amp;T (Remember that GIM is dialect dependant.). So let's prepare an instance of
the Intel dialect:
</p>
<pre class="brush: cpp">
#include &lt;fcml_intel_dialect.h&gt;

fcml_st_dialect *dialect;
fcml_ceh_error error = fcml_fn_dialect_init_intel( FCML_INTEL_DIALECT_CF_DEFAULT, &amp;dialect );
if( error ) {
	printf( "Can not initialize dialect, error: %d\n", error );
	exit(EXIT_FAILURE);
}
</pre>
<p>
As you can see, there are dedicated functions to create different dialects. Every function can also
take additional parameters used to configure the initialized dialect. In theory it should be possible to
implement every existing dialect for FCML library, but currently only the Intel and AT&amp;T (called GAS)
dialects are supported. For the sake of example the Intel dialect (the preferred one) is used.
</p>
<div class="notice-box">
The Intel dialect was the first dialect which was supported by FCML library and as such it is more mature. Anyway AT&amp;T
dialect is also fully supported and unit tested and can be safely considered as a stable one.
</div>
<p>
The dialect is ready, so let's initialize the disassembler instance using <i><a href="api/fcml__disassembler_8h.html#a795996631b091a97e7ae1d04a6015522">fcml_fn_disassembler_init</a></i>
function.
</p>
<pre class="brush: cpp">
fcml_st_disassembler *disassembler;
error = fcml_fn_disassembler_init( dialect, &amp;disassembler );
</pre>
<p>
To make code a bit clearer, error handling has been avoided in this case, but it should be
implemented in the same way as in case of the dialect initialization. All possible error codes are defined
in the header file <i><a href="api/group__ERRORS__GROUP.html#ga88406cc59b708d9f4de9286d254dd10a">fcml_errors.h</a></i>
</p>
<p>
Having initialized the dialect and disassembler, there is the last thing to be done before
disassembling is possible. It is the disassembler result structure. This structure is reusable so it has
to be prepared in the right way in order to allow the disassembler to reuse it correctly. To do so, a
manually allocated structure has to be passed to <i><a href="api/structfcml__st__disassembler__result.html">fcml_fn_disassembler_result_prepare</a></i> function:
</p>
<pre class="brush: cpp">
fcml_st_disassembler_result result;
fcml_fn_disassembler_result_prepare( &amp;result );
</pre>
<p>
That is all, the disassembler is prepared to do its job, so let's try to disassemble a piece of example
machine code.
</p>
<p>
The main structure which has to be properly prepared for the disassembler to work is <i><a href="api/structfcml__st__disassembler__context.html">fcml_st_disassembler_context.</a></i>
It consists of the previously initialized disassembler instance which
should be used to disassemble the machine code, some configuration flags we can use to configure
disassembling process, entry point which will be used to inform the disassembler about the code
segment the instruction is located in and a piece of the instruction machine code. The disassembler
context itself can be initialized on the stack, but it is very important to clear the memory it uses before
passing it to the disassembler. We should do it just to set all configuration options and other
parameters to its default values. For example the following source code shows the proper way to initialize the
disassembler context:
</p>
<pre class="brush: cpp">
fcml_st_disassembler_context context = {0};
</pre>
<p>
Let's start by setting the configuration options. For now there is only one flag we are interested in. It is
<i><a href="api/structfcml__st__disassembler__conf.html#a558b58f6dca6b073020970950e87707b">enable_error_messages</a></i> which is responsible for enabling textual error messages, which can be used
to identify potential errors and as such they should be very helpful for beginners. The second flag
that might be interesting here is <i><a href="api/structfcml__st__disassembler__conf.html#a1f91b6e27453c19fe1896bb121f4ae87">short_forms</a></i> and it has to be set to true in order to instruct the
assembler to use a short instruction forms whenever possible (For instance '<span class="instruction">cmpsw'</span> instead of '<span class="instruction">cmps
word ptr [si],word ptr [di]</span>'.) The <i>short_forms</i> flag impacts the generated GIM, so it should be used
carefully.
</p>
<pre class="brush: cpp">
context.configuration.enable_error_messages = FCML_TRUE;
context.configuration.short_forms = FCML_TRUE;
</pre>
<p>
The disassembler is configured but we still have not provided any machine code yet. It can be
done by setting two additional context fields <i><a href="api/structfcml__st__disassembler__context.html#a773efa2fa6b9600627b5b85f1570109d">code</a></i> and <i><a href="api/structfcml__st__disassembler__context.html#aa517a01756088a93f0f5608632c511ac">code_length</a></i>:
</p>
<pre class="brush: cpp">
context.code = code;
context.code_length = sizeof( code );
</pre>
<p>
The <i>code</i> should be a pointer to an array of bytes which contains instruction machine code and <i>code_length</i>
of course holds the length of the array in bytes.
</p>
<p>
The machine code is configured now, but we known nothing about the code section, so it is time to set the
instruction pointer and processor addressing mode by setting the entry point structure correctly
(If you do not known what the instruction pointer, address size attribute or processor operating
mode are, you definitely should at least read this chapter: <a href="#un-entry-point">Understanding entry point</a>)
</p>
<p>
The structure <i><a href="api/structfcml__st__entry__point.html">fcml_st_entry_point</a></i> holds basic information about the code section and the instruction pointer
of the instruction. Thanks to it we can set value of the IP/EIP or RIP register that points to the
instruction machine code in the memory. It is very important to set it correctly, because this information is
used to calculate relative offsets for example. The first required field is <i><a href="api/structfcml__st__entry__point.html#af051b1f4faee0516e00180887e36fc31">op_mode</a></i> which describes
the processor operating mode (<i><a href="api/fcml__common_8h.html#aa842ef70ab3255bbffe239aa2bffdd1b">FCML_OM_16_BIT</a></i>, <i><a href="api/fcml__common_8h.html#aa842ef70ab3255bbffe239aa2bffdd1b">FCML_OM_32_BIT</a></i> or <i><a href="api/fcml__common_8h.html#aa842ef70ab3255bbffe239aa2bffdd1b">FCML_OM_64_BIT</a></i>). We can also set default values for the address size
attribute and operand size attribute for our "virtual" code segment:
</p>
<pre class="brush: cpp">
context.entry_point.op_mode = FCML_OM_32_BIT;
context.entry_point.address_size_attribute = FCML_DS_UNDEF;
context.entry_point.operand_size_attribute = FCML_DS_UNDEF;
context.entry_point.ip = 0x00401000;
</pre>
<p>
The disassembler context is almost initialized, we have left the most important thing at the end. It is
the disassembler itself. It has to be also put into the context, because it will be used to do the whole job:
</p>
<pre class="brush: cpp">
context.disassembler = disassembler;
</pre>
<p>
The following piece of source code shows how the whole context initialization should looks like:
</p>
<pre class="brush: cpp">
fcml_st_disassembler_context context = {0};
context.disassembler = disassembler;
context.configuration.enable_error_messages = FCML_TRUE;
context.configuration.short_forms = FCML_TRUE;
context.code = code;
context.code_length = sizeof( code );
context.entry_point.op_mode = FCML_OM_32_BIT;
context.entry_point.address_size_attribute = FCML_DS_UNDEF;
context.entry_point.operand_size_attribute = FCML_DS_UNDEF;
context.entry_point.ip = 0x00401000;
</pre>
<p>
Now we are ready to disassemble the first piece of machine code, so let's do it. In order to disassemble
anything we have to call the function <i><a href="api/fcml__disassembler_8h.html#a26d4fb7b2eae675eeaaadbd950881c07">fcml_fn_disassemble</a></i> (Definition Below).
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_disassemble(
	fcml_st_disassembler_context *context, 
	fcml_st_disassembler_result *result );
</pre>
<p>
The function gets the disassembler context and disassembler result as arguments:
</p>
<pre class="brush: cpp">
error = fcml_fn_disassemble( &amp;context, &amp;result );
if( !error ) {
	…
}
</pre>
<p>
If everything succeeded, the error code is <i>FCML_CEH_GEC_NO_ERROR</i> and the result contains the disassembled instruction in
the form of the generic instruction model. Let's take a look at <i><a href="api/structfcml__st__disassembler__result.html">fcml_st_disassembler_result</a></i> structure.
Field <i><a href="api/structfcml__st__disassembler__result.html#a8f402916076e73413bc1a31dbdb78141">errors</a></i> contain error messages if the function failed (Or potential warnings in case of success).
</p>
</p>
There is also <i><a href="api/structfcml__st__instruction__details.html">fcml_st_instruction_details</a></i> structure which consists of additional information which is
not relevant for the general instruction model but anyway can be useful through the process of the instruction analysis.
</p>
<p>
Now we have a general instruction model, but what if we would like to print a textual representation of
the instruction for the user? There is nothing easier than that. You only have to configure a
instruction renderer and render the GIM to the provided buffer. So let's do it, but at first take a look at
the function we will use to render our instruction model:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_render( fcml_st_dialect *dialect,
	fcml_st_render_config *config, 
	fcml_char *buffer, 
	fcml_usize buffer_len,
	fcml_st_disassembler_result *result );
</pre>
<p>
This function needs quite a few parameters, but take into account that there is only one argument that
has to be carefully prepared. It is <i><a href="api/structfcml__st__render__config.html">fcml_st_render_config</a></i> structure which configures some aspects
of the rendering process. It is also not so complicated, because it contains only a few rendering flags
(see: <a href="#instruction-renderer">Instruction renderer</a>) and padding configuration. So let's prepare the configuration:
</p>
<pre class="brush: cpp">
fcml_st_render_config render_config = {0};
render_config.render_flags = FCML_REND_FLAG_HEX_IMM | 
							 FCML_REND_FLAG_HEX_DISPLACEMENT;
</pre>
<p>
The next two parameters that follow the configuration: <i>buffer</i> and <i>buffer_length</i> point to the output buffer,
where textual representation of the instruction will be rendered. You can allocate this buffer in the
following way:
</p>
<pre class="brush: cpp">
fcml_uint8_t buffer[FCML_INSTRUCTION_SIZE];
</pre>
<p>
Remember that the buffer is also reusable and does not have to be cleaned between multiple calls
to the rendering function.
</p>
<p>
We have prepared all needed parameters, so let's render the instruction from the disassembler result:
</p>
<pre class="brush: cpp">
fcml_ceh_error error = fcml_fn_render( dialect, render_config, 
	buffer, sizeof( buffer ), result );
</pre>
<p>
As you can see we pass the whole disassembler result structure to the renderer. It is
important to note that in order to render the instruction we need the whole result, a GIM is not enough here. It is why the whole
result is passed as the parameter, because it contains <i><a href="api/structfcml__st__instruction__details.html">fcml_st_instruction_details</a></i> structure which is
also used by the renderer. Although it is possible to prepare such a disassembler result by hand and
pass it the renderer, it would be very risky (mostly because there is some information destined only
for renderers like hints), so remember to use renderers only with structures prepared by FCML
disassembler. The last thing to remember is to use the same dialect that was used by the
disassembler.
</p>
<p>
When resources are no longer needed they have to be freed. The following source code frees the
disassembler result, disassembler itself and the dialect:
</p>
<pre class="brush: cpp">
fcml_fn_disassembler_result_free( &amp;dis_result );
fcml_fn_disassembler_free( disassembler );
fcml_fn_dialect_free( dialect );
</pre>
<p>
Remember that <i><a href="api/fcml__disassembler_8h.html#aacd6d5618c7e460cde65188c5c8ba241">fcml_fn_disassembler_result_free</a></i> function does not free the result structure itself. It
is only responsible for freeing all structures allocated by the disassembler which are accessible through
the disassembler result, like error messages for instance. It is why you can still reuse the structure, even if it was freed before.
</p>
<p>
See the <a href="#instruction-renderer">Instruction renderer</a> chapter for working example.
</p>

<!---- **** MANUAL **** ---->

<h1 id="manual">Manual</h1>

<p>
This manual covers every aspect of FCML library in very detail. Take into account that good
knowledge of x68_64 architecture is required to understand the following chapters. Of
course if everything you need is to disassembler a piece of machine code and to render it to the textual form
or to assemble a bit of machine code without playing much with the generic instruction models the <a href="#quick_start">Quick
Start</a> and maybe <a href="#parser">Parser</a> chapters should be fair enough for you. 
</p>

<h2 id="generic_instruction_model">Generic instruction model</h2>
<p>
The generic instruction model (GIM) is a common structure which is used to describe the instruction
in a common way used by FCML assembler and disassembler. That is, in case of FCML library
assembling and disassembling operations are symmetrical. It means that the instruction model
returned by the disassembler can be then assembled back to get the same piece of machine code that was disassembled earlier.
The generic instruction model consists of an instruction mnemonic, optional prefixes, condition (in case
of conditional instructions) and of course instruction operands. This chapter describes every field of
the GIM structure in details. The following code shows the GIM structure declaration:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_instruction {
	fcml_prefixes prefixes;
	fcml_hints hints;
	fcml_char *mnemonic;
	fcml_bool is_conditional;
	fcml_st_condition condition;
	fcml_st_operand operands[FCML_OPERANDS_COUNT];
	fcml_int operands_count;
} fcml_st_instruction;
</pre>
<div class="notice-box">
I've decided to copy various structure declarations through the manual, because in my opinion
it is a lot easier to remember structure details and overall idea having the declarations in front
of our eyes when they are discussed. Nevertheless, all comments have been removed to avoid redundancy
and increase readability.
</div>

<h3 id="prefixes">Prefixes</h3>
<p>
The first field <i><a href="api/structfcml__st__instruction.html#a43ba34c9c651682f9894e31d891b9b7f">prefixes</a></i> defines all explicitly set prefixes than are used by the instruction. This is the list
of allowed prefixes:
</p>
<pre class="brush: cpp">
#define FCML_PREFIX_LOCK            0x0001
#define FCML_PREFIX_REPNE           0x0002
#define FCML_PREFIX_REPNZ           FCML_PREFIX_REPNE
#define FCML_PREFIX_REP             0x0004
#define FCML_PREFIX_REPE            FCML_PREFIX_REP
#define FCML_PREFIX_REPZ            FCML_PREFIX_REP
#define FCML_PREFIX_XACQUIRE        0x0008
#define FCML_PREFIX_XRELEASE        0x0010
#define FCML_PREFIX_BRANCH_HINT     0x0020
#define FCML_PREFIX_NOBRANCH_HINT   0x0040
</pre>
<p>
These definitions are self-describing so, there is no need to waste time describing them. One thing worth mentioning here is
that they all are defined as bit masks so you can set more than one prefix for the instruction if needed.
</p>

<h3 id="instruction_level_hints">Instruction level hints</h3>
<p>The second field <i><a href="api/structfcml__st__instruction.html#a885afc2e9220030ed2d0a2600cc870ac">hints</a></i> is used to set some instruction level hints for the assembler/renderer (Every
disassembler instance also sets them, so fell free to use them whenever possible). Currently there
are following hints supported:</p>
<pre class="brush: cpp">
typedef enum fcml_en_instruction_hints {
    FCML_HINT_FAR_POINTER = 0x0001,
    FCML_HINT_NEAR_POINTER = 0x0002,
    FCML_HINT_LONG_FORM_POINTER = 0x0004,
    FCML_HINT_INDIRECT_POINTER = 0x0008
} fcml_en_instruction_hints;
</pre>
<p>
<dl>
	<dt>FCML_HINT_FAR_POINTER</dt>
	<dd>
		<p>
			This hint is set for instructions which use far pointers:
			<ul>
				<li>LDS, LSS, LES, LFS, LGS</li>
				<li>CALL and JMP instructions which use far absolute indirect addresses.</li>
				<li>CALL and JMP instructions which use far absolute direct addresses.</li>
			</ul>
			If the hint is set, the Intel renderer adds "far" keyword just after the mnemonic, and GAS/AT&amp;T
			renderer adds "l" as a prefix to the <i>call</i> and <i>jmp</i> mnemonics. Parsers also set this hint if the
			appropriate keyword or mnemonic (In case of AT&amp;T) is used.
			<div class="notice-box">
				Every time I refer to "Intel renderer" or "AT&amp;T renderer" I mean a renderer called with an appropriate dialect.
			</div>
		</p>
	</dd>
	<dt>FCML_HINT_NEAR_POINTER</dt>
	<dd><p>This flag is always set if the ModR/M based near addressing is used.</p></dd>
	<dt>FCML_HINT_LONG_FORM_POINTER</dt>
	<dd>
		<p>
			This hint is interpreted only by the assembler and can be used in order to force it to generate three-byte VEX/XOP prefix
			even if prefix fields fit into two bytes. For now it is supported by the Intel syntax only and can be
			set using "long_form" keyword just after the instruction mnemonic. For instance: "<span class="instruction">vrcpps
			long_form xmm2,xmmword ptr [eax]</span>" assembles to: <tt><b>C4E178</b>5310</tt> (VEX/XOP prefixes in bold),
			but "<span class="instruction">vrcpps ymm2,ymmword ptr [rax]</span>" assembles to: <tt><b>C5FC</b>5310</tt>. If you do not know what
			these prefixes are just ignore that. This is very specialized functionality and you will probably never need it.
		</p>
	</dd>
	<dt>FCML_HINT_INDIRECT_POINTER</dt>
	<dd>
		<p>
			This hint is set for instructions which use indirect pointers:
			<ul>
				<li>CALL and JMP which use near absolute indirect addresses.</li>
				<li>CALL and JMP which use far absolute indirect addresses.</li>
			</ul>
		</p>
	</dd>
</dl>
</p>

<h3 id="mnemonic">Mnemonic</h3>
<p>
	The next field <i><a href="api/structfcml__st__instruction.html#adf44ce9432995b2257325f988ddab589">mnemonic</a></i> stores an instruction mnemonic. For instance: "cmps", "mov", "vrcpps", etc.
	Take into account that the instruction mnemonic is allocated and built by the disassembler, so the disassembler is
	responsible for freeing it while <i><a href="api/fcml__disassembler_8h.html#aacd6d5618c7e460cde65188c5c8ba241">fcml_fn_disassembler_result_free</a></i> function is called, or when the
	disassembler result is reused by the disassembler. So if you would like to store it somewhere, you have to make a duplicate.
</p>

<h3 id="conditional_instructions">Conditional instructions</h3>
<p>
	The next two fields describe conditional instructions: <i><a href="api/structfcml__st__instruction.html#aef419b4fb5575be3e0c509962fc5ce80">is_conditional</a></i> and <i><a href="api/structfcml__st__instruction.html#a281d514e08d27178fe2b0a294245b2e6">condition</a></i>. The first one is set to
	<i>FCML_TRUE</i> for all conditional instructions: CMOV, Jcc (JA, JG, JNG, ...), SETcc (SETG,
	SETNG, …). If the first one is set to <i>FCML_TRUE</i>, the second one describes the condition used by the
	instruction.
</p>
<pre class="brush: cpp">
typedef struct fcml_st_condition {
    fcml_en_condition_type condition_type;
    fcml_bool is_negation;
} fcml_st_condition;
</pre>
<p>
	The condition type enumerator contains following values:
</p>
<pre class="brush: cpp">
typedef enum fcml_en_condition_type {
	/* 0 Overflow*/
	FCML_CONDITION_O = 0,
	/* 1 Below*/
	FCML_CONDITION_B,
	/* 2 Equal*/
	FCML_CONDITION_E,
	/* 3 Below or equal*/
	FCML_CONDITION_BE,
	/* 4 Sign*/
	FCML_CONDITION_S,
	/* 5 Parity*/
	FCML_CONDITION_P,
	/* 6 Less than*/
	FCML_CONDITION_L,
	/* 7 Less than or equal to*/
	FCML_CONDITION_LE
} fcml_en_condition_type;
</pre>
<p>
	As you can see they are in consonance with suffixes used by conditional mnemonics. Of course
	mnemonics can also negate these conditions and it is where the next field <i>is_negation</i> plays a part in
	describing the condition as a whole.
</p>
<p>
	For example the mnemonic: SETNBE has <i>condition_type</i> field set to <i>FCML_CONDITION_BE</i> and
	is_negation to <i>FCML_TRUE</i>.
</p>

<h3 id="operands">Operands</h3>
<p>
The next instruction field <i><a href="api/structfcml__st__instruction.html#a132b18d5328984f2ee54f08457b3b8a1">operands</a></i> is an array of available operands. The number of operands available in the array is defined by another field <i><a href="api/structfcml__st__instruction.html#a9869fe0b69a9721ec051782001c78776">operands_count</a></i>. Every operand is an instance of the following structure:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_operand {
    fcml_en_operand_type type;
    fcml_hints hints;
    fcml_st_immediate immediate;
    fcml_st_far_pointer far_pointer;
    fcml_st_address address;
    fcml_st_register reg;
} fcml_st_operand;
</pre>
<p>
The first field <i><a href="api/structfcml__st__operand.html#a6dcde42179ad3f6ce5b9f0ff3de2dd7a">type</a></i> stores the operand type:
</p>
<pre class="brush: cpp">
typedef enum fcml_en_operand_type {
	FCML_OT_NONE,
	FCML_OT_IMMEDIATE,
	FCML_OT_FAR_POINTER,
	FCML_OT_ADDRESS,
	FCML_OT_REGISTER
} fcml_en_operand_type;
</pre>
<dl>
	<dt>FCML_OT_NONE</dt>
	<dd><p>Operand is not defined. It means that it is just not used.</p></dd>
	<dt>FCML_OT_IMMEDIATE</dt>
	<dd><p>Immediate integer value (Can be also used to specify near relative addressing in some cases).</p></dd>
	<dt>FCML_OT_FAR_POINTER</dt>
	<dd><p>Describes far absolute address given in operand.</p></dd>
	<dt>FCML_OT_ADDRESS</dt>
	<dd><p>Effective address.</p></dd>
	<dt>FCML_OT_REGISTER</dt>
	<dd><p>One of the supported registers.</p></dd>
</dl>

<h4 id="op-hints">Hints</h4>
<p>
We will get through all operands types later, for now let's take a look at operand hints which are
counterparts to the instruction hints described in the case of <i><a href="api/fcml__common_8h.html#a04112d045d2dd9efbf6fdb66c07920de">fcml_st_instruction</a></i> structure:
</p>
<pre class="brush: cpp">
typedef enum fcml_en_operand_hints {
	FCML_OP_HINT_MULTIMEDIA_INSTRUCTION = 0x0001,
	FCML_OP_HINT_DISPLACEMENT_RELATIVE_ADDRESS = 0x0002,
	FCML_OP_HINT_PSEUDO_OPCODE = 0x0004,
	FCML_OP_HINT_ABSOLUTE_ADDRESSING = 0x0008,
	FCML_OP_HINT_RELATIVE_ADDRESSING = 0x0010,
	FCML_OP_HINT_SIB_ENCODING = 0x0020
} fcml_en_operand_hints;
</pre>
<dl>
	<dt>FCML_OP_HINT_MULTIMEDIA_INSTRUCTION</dt>
	<dd>
		<p>
			All operands which use SIMD registers (mmx, xmm, ymm) have this flag set. It is for instance used
			by the Intel renderer for rendering following data size operators: mmword ptr, xmmword ptr, ymmword ptr. For more details head over to the following section: <a href="#parser-intel-size-operators">Size operators for Intel dialect</a>.
		</p>
	</dd>
	<dt>FCML_OP_HINT_DISPLACEMENT_RELATIVE_ADDRESS</dt>
	<dd>
		<p>
			This hint is set for all branches which use jumps calculated by the displacement relative to the
			instruction pointer of the next instructions. XBEGIN also uses such addressing mode and has this
			hint set (See RTM – Restricted Transactional Memory for more details.). This flag is set by the
			disassembler only, so you can silently ignore it in the case of hand made generic instruction models.
		</p>
	</dd>
	<dt>FCML_OP_HINT_PSEUDO_OPCODE</dt>
	<dd>
		<p>This hint is set for the last operand (Intel syntax) which contains a comparison predicate of the
			following instructions: CMPSD, VCMPSD, CMPSS, VCMPSS, VPCOMB, VPCOMW, VPCOMD,
			VPCOMQ, VPCOMUB, VPCOMUW, VPCOMUD, VPCOMUQ. It is used only internally by
			the disassembler in order to remove the mentioned operand if pseudo-ops forms of these
			instructions are used (See: <a href="#disassembler-analyse-shortcuts">Shortcuts</a>). For instance the instruction "<span class="instruction">cmpsd xmm1, xmm2, 4</span>" can be encoded using the pseudo-op form "<span class="instruction">cmpneqsd xmm1, xmm2</span>" which encodes the
			condition from the last operand (4) inside the instruction mnemonic. In the first case the comparison predicate will be
			available in the last <i><a href="api/fcml__common_8h.html#a994f4559614a86c993b3e86b88810c13a5677a2b9d514cfed78e45451d3725e7c">FCML_OT_IMMEDIATE</a></i> operand and the operand will have this hint set. Nonetheless in the pseudo-op form this operand will not be available in the GIM
			at all. So finally this hint is fairly useless and essentially can only be used to check if the operand
			contains comparison predicate for the mentioned instructions when short forms are disabled.
		</p>
	</dd>
	<dt>FCML_OP_HINT_ABSOLUTE_ADDRESSING, FCML_OP_HINT_RELATIVE_ADDRESSING</dt>
	<dd>
		<p>
			As opposed to the previous hint these hints are really important and both the assembler and
			disassembler can make a good use of them. They are usable only in 64 bit mode where RIP
			addressing was introduced. In general, they can be used to hint the assembler whether certain immediate integer
			value should be interpreted as absolute offset or displacement relative to RIP (See <a href="#dialects">Dialects</a> chapter
			for more information about how to use these hints with Intel and AT&amp;T dialects).
		</p>
	</dd>
	<dt>FCML_OP_HINT_SIB_ENCODING</dt>
	<dd>
		<p>
			There are instructions which can be encoded with or without the SIB byte. For example the
			following instruction "<span class="instruction">add dword ptr [eax+00000001h],eax</span>" can be encoded to the form
			without the SIB byte: <tt>014001</tt>, or to the longer form with the SIB byte <tt>0144<b>20</b>01</tt> encoded in it. Using this hint
			together with the operand which contains effective address you can force assembler to use the SIB
			byte even if it is superfluous. FCML Intel parser also supports this hint, so for instance
			you can parse the following instruction correctly "<span class="instruction">add dword ptr [<b>sib</b> eax+00000001h],eax</span>”,
			but AT&amp;T dialect currently does not handle this syntax and probably will not in the future.
		</p>
	</dd>
</dl>

<h4 id="op-immediate">Immediate value operand</h4>
<p>
Immediate operands are encoded using the following structure:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_integer {
    fcml_usize size;
    fcml_bool is_signed;
	fcml_int8_t int8;
	fcml_int16_t int16;
	fcml_int32_t int32;
	fcml_int64_t int64;
} fcml_st_integer;
</pre>
<p>
	The field <i>size</i> contains the immediate value size in bits, so it should be set to 8,16, 32 or 64
	(See: <i>FCML_DS_16</i>, <i>FCML_DS_32</i>, etc. macros). The value can also be set signed or unsigned using <i>is_signed</i> flag. This
	flag is very important in cases when the value has to be extended. For example we have 8-bit
	0xFF value set inside <i>int8</i> field, but instruction needs 16-bit immediate operand. In such a case
	the value has to be extended to fit 16 bits. If the value was signed, it would be extended to 0xFFFF
	and in case of the unsigned value it would be extended to 0x00FF. Fields <i>int8</i>, <i>int16</i>, <i>int32</i>,
	int64 holds the integer values we would like to set for the operand. If we have set the size to 8
	bits we have to use the <i>int8</i> field and so on. Using different fields for every size has its advantages
	and disadvantages, but it can save us from certain problems related to the type casting.
</p>
<p>
	For instance if we would like to set 16-bit signed value -256 for the operand, we can do it like this:
</p>
<pre class="brush: cpp">
fcml_st_immediate imm = {0};
imm.imm_size = FCML_DS_16;
imm.is_signed = FCML_TRUE;
imm.imm16 = -256;
</pre>

<h4 id="op-far-pointer">Far pointer operand</h4>
<p>
	The structure below is used to specify the direct far pointer addressing for branch instructions (JMP,
	CALL):
</p>
<pre class="brush: cpp">
typedef struct fcml_st_far_pointer {
	fcml_uint16_t segment;
	fcml_data_size offset_size;
	fcml_uint16_t offset16;
	fcml_uint32_t offset32;
} fcml_st_far_pointer;
</pre>
<p>
	A far pointer consists of a segment value and an offset relative to the segment value. The field
	segment contains a segment value, whereas <i>offset_size</i> and <i>offset16</i>/<i>offset32</i> hold the offset relative
	to this value. The offset can be 16 or 32 bit in length. The size differs depending on the processor
	operating mode. All 16-bit code segments use 16-bit offsets and 32-bit code segments use 32-bit
	offsets and in case of 64-bit mode direct far pointers are not supported, so there is no need to
	provide <i>offset64</i> field.
</p>

<h4 id="op-address-operand">Address operand</h4>
<p>
	The address operand is without a doubt the most advanced operand type here. It is used to specify an
	absolute/relative offset or a full effective address which consists of several different fields
	describing the memory addressing. The following structure is used to describe it:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_address {
	fcml_data_size size_operator;
	fcml_en_effective_address_form address_form;
	fcml_st_segment_selector segment_selector;
	fcml_st_effective_address effective_address;
	fcml_st_offset offset;
} fcml_st_address;
</pre>
<p>
	Every field here has a quite a long description, so let's break the overall convention and organise them as a simple list this time:
</p>
<dl>
	<dt>Field: size_operator</dt>
	<dd>
		<p>
			The first field defines the size of the data we would like to access using the encoded address (It
			corresponds to the "word ptr", "byte ptr" etc. size operators in case of the Intel syntax.). 
		</p>
	</dd>
	<dt>Field: address_form</dt>
	<dd>
		<p>
			The second field <i><a href="api/structfcml__st__address.html#a740d1300275f95c1a9657fe6170d1da9">address_form</a></i> is used to inform the assembler about the type of the effective
			address being used:
		</p>
		<pre class="brush: cpp">
typedef enum fcml_en_address_form {
	FCML_AF_UNDEFINED,
	FCML_AF_OFFSET,
	FCML_AF_COMBINED
} fcml_en_effective_address_form;
		</pre>
		<dl>
			<dt>FCML_AF_OFFSET</dt>
			<dd>
				<p>
					<p>
						The address type used when the operand represents a direct absolute offset (address) relative to the current code segment. 
						Take into account that it tells nothing about the representation of the address on the
						instruction machine code level. It is up to the assembler to decide what addressing form would be the
						best to be used in a given case (Relative or absolute). For some instructions the assembler might decide to encode it as a displacement value relative to the instruction pointer, whereas for others it may be the
						best just to encode the offset as a direct absolute address. For 16 and 32 bit processor operating modes the offset is
						always encoded as an absolute address (In case of ModR/M addressing.), because it is the only way
						the assembler is able to encode it using the ModR/M fields, but in case of the 64-bit operating
						mode it may choose between an absolute addressing and RIP-relative addressing introduced for 64-bit processors.
					</p>
					<p>
						So to sum up, we have to use it if we would like to pass a direct <b>absolute address</b> to the assembler
						and we do not care how it will be encoded at the end. If you choose this address form, use <i><a href="api/structfcml__st__address.html#a40a2712aeb5702927837ecb6ee7a472c">offset</a></i>
						field of the <i><a href="api/structfcml__st__address.html">fcml_st_address</a></i> structure in order to specify the absolute offset.
					</p>
					<p>
						The assembler can encode this operand type using one of the following forms:
					</p>
					<p>
						<ul>
							<li>
								The effective memory addressing encoded using the ModR/M fields.
							</li>
							<li>
								A displacement relative to the instruction pointer encoded directly as the
								immediate operand of the encoded instruction (JMP, CALL etc.).
							</li>
							<li>
								An absolute offset directly encoded as the immediate operand of the instruction (MOV).
							</li>
						</ul>
					</p>
					<p>
						I have pointed out that it is up to the assembler to choose the best way to decode the absolute offset.
						It can choose between the absolute or relative addressing if there is such possibility, but what if we
						would like to use the certain one? There are two ways to achieve it. 
					</p>
					<p>The first way is a global one
						and is based on the assembler configuration where <i><a href="api/structfcml__st__assembler__conf.html#af414788abdcea016116c9bde6d874fa4">choose_abs_encoding</a></i> field can be used to choose the preferred way to encode offsets. Set it to <i>FCML_TRUE</i> to hint assembler
						to treat absolute addressing as the preferred one.
					</p>
					<p>The second one is to use the following operand level
						hints: <i>FCML_OP_HINT_ABSOLUTE_ADDRESSING</i>,
						<i>FCML_OP_HINT_RELATIVE_ADDRESSING</i>. They are self-describing but for more information
						see: <a href="#op-hints">Hints</a>. 
					</p>
					<p>
						Features above are especially useful when you need to generate position-independent machine code for example, but it is a little tricky solution which should be used carefully. Notice that the configuration as well as the operand flags always refer to the one instruction being assembled at a given moment, so if certain instruction can not be encoded using preferred addressing form the one possible will be chosen and currently there is no way to check the final decision made by the assembler.
					</p>
					<p>
						There is one more thing you should be aware of. Even if <i>FCML_AF_OFFSET</i> address type has
						been used, in some cases you can still encode the absolute offset directly as the displacement value
						relative to the instruction pointer using <i><a href="api/structfcml__st__effective__address.html">fcml_st_effective_address</a></i> structure, by setting the displacement directly in the 
						<i><a href="api/structfcml__st__effective__address.html#aa5eb5b5d3f9dc3817fd59ad3904022a6">displacement</a></i> field. It is possible only for 16 and 32 bit processor operating
						modes, because in these modes the absolute offset is just encoded in the displacement
						(ModR/M field.) anyway. This trick is not possible in the 64-bit addressing mode. This feature is
						rather useless on day-to-day usage and should not be used due to its inconsistency! It just breaks the rule that <i>FCML_AF_OFFSET</i> is always encoded using <i><a href="api/structfcml__st__offset.html">fcml_st_offset</a></i> structure.
					</p>
				</p>
			</dd>
			<dt>FCML_AF_COMBINED</dt>
			<dd>
				<p>
					This type should be used if we would like to encode an effective address indirectly by computing
					following components: a displacement, base register, index register and scale factor. To encode
					the effective address use <i><a href="api/structfcml__st__address.html#af5de28edc4a37fd6357146ba9a3d6f92">effective_address</a></i> field of the <i><a href="api/structfcml__st__address.html">fcml_st_address</a></i> structure.
				</p>
			</dd>
		</dl>
	</dd>
	<dt>Field: segment_selector</dt>
	<dd>
		<p>
			The next field of <i><a href="api/structfcml__st__address.html">fcml_st_address</a></i> structure <i><a href="api/structfcml__st__address.html#a5ec7736fef7fb63bedcc6f08ee29b0bd">segment_selector</a></i> contains a segment selector which can be used to define the segment selector register
			that should be used by the instruction. As you probably know there are default segment registers for
			certain segments. For example CS is the default register for code segments and DS is the default
			register for data segments, etc. Anyway in some cases these registers can be overridden using
			special instruction prefixes. If you would like to address the memory using a non-standard register,
			you are able to do it using this field. Take a look at the structure which describes the segment selector:
		</p>
<pre class="brush: cpp">
typedef struct fcml_st_segment_selector {
	fcml_st_register segment_selector;
	fcml_bool is_default_reg;
} fcml_st_segment_selector;
</pre>
		<p>
			The first field <i><a href="api/structfcml__st__segment__selector.html#a9ead6e86b92ca7f526f1fc63484cfe78">segment_selector</a></i> is the segment register and should be set to one of the available
			segment registers. Second field <i><a href="api/structfcml__st__segment__selector.html#a26fba56387e961f9b908abc1c0282ae6">is_default_reg</a></i> is filled only by the disassembler and can be used to
			check if register returned by the disassembler is the default one or maybe the one placed here as the
			result of the segment register overriding.
		</p>
	</dd>
	<dt>Field: effective_address</dt>
	<dd>
		<p>
			The next field <i><a href="api/structfcml__st__address.html#af5de28edc4a37fd6357146ba9a3d6f92">effective_address</a></i> has to be used when <i><a href="api/structfcml__st__address.html#a740d1300275f95c1a9657fe6170d1da9">address_form</a></i> field is set to
			<i>FCML_AF_COMBINED</i>. It consists of all components which take part in the effective address
			computation:
		</p>
		<pre class="brush: cpp">
typedef struct fcml_st_effective_address {
	fcml_st_register base;
	fcml_st_register index;
	fcml_uint8_t scale_factor;
	fcml_st_integer displacement;
} fcml_st_effective_address;
		</pre>
		<p>
			There is nothing special about this structure. The fields: base and index should be set to general purpose
			registers and the scale factor to the 8-bit integer value: 2,4 or 8. 
		</p>
		<p>
			The displacement field may look very familiar to you if you have already read about immediate operands before, because it
			uses the same <i><a href="api/structfcml__st__integer.html">fcml_st_integer</a></i> structure (See: <i><a href="#op-immediate">Immediate value operand</a></i>.).
		</p>
		<p>
			One more thing to notice: in general, the effective address is used to describe an indirect addressing
			but you are perfectly allowed to fill the displacement structure only, forcing the assembler to encode
			displacement as an absolute address in case of 16, 32 and as a relative address in case of the 64-bit
			addressing. The displacement is just encoded as it is, without any additional calculations.
		</p>
	</dd>
	<dt>Field: offset</dt>
	<dd>
		<p>
			The last field of the <i><a href="api/structfcml__st__address.html">fcml_st_address</a></i> structure is <i><a href="api/structfcml__st__address.html#a40a2712aeb5702927837ecb6ee7a472c">offset</a></i>. It uses the following structure to describe the memory address:
		</p>
<pre class="brush: cpp">
typedef struct fcml_st_offset {
	fcml_usize size;
	fcml_bool is_signed;
	fcml_int16_t off16;
	fcml_int32_t off32;
	fcml_int64_t off64;
} fcml_st_offset;
</pre>
		<p>
			This structure follows the same model as the immediate value operand and displacement described above.
			There is only one difference. It does not allow to specify 8-bit values. It is because the lowest size
			for the absolute address is exactly 16 bits.
		</p>
	</dd>
</dl>

<h4 id="op-register-operand">Register operand</h4>
<p>
	Register operand specifies a register we would like to use as an instruction operand.
	The following structure describes them:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_register {
	fcml_en_register type;
	fcml_usize size;
	fcml_uint8_t reg;
	fcml_bool x64_exp;
} fcml_st_register;
</pre>
<p>
	The first field should be set to the appropriate register type:
</p>
<pre class="brush: cpp">
typedef enum fcml_en_register {
	FCML_REG_UNDEFINED = 0,
	FCML_REG_GPR,
	FCML_REG_SIMD,
	FCML_REG_FPU,
	FCML_REG_SEG,
	FCML_REG_CR,
	FCML_REG_DR,
	FCML_REG_IP
} fcml_en_register;
</pre>
<p>
All available types are described below:
</p>
<dl>
	<dt>FCML_REG_GPR</dt>
	<dd><p>General purpose registers like FCML_REG_AL, FCML_REG_AX etc.</p></dd>
	<dt>FCML_REG_SIMD</dt>
	<dd><p>SIMD registers like FCML_REG_MM1, FCML_REG_XMM1, FCML_REG_YMM1.</p></dd>
	<dt>FCML_REG_FPU</dt>
	<dd><p>FPU registers FCML_REG_ST0, FCML_REG_ST2 etc.</p></dd>
	<dt>FCML_REG_SEG</dt>
	<dd><p>FCML_REG_ES, FCML_REG_CS, FCML_REG_SS etc.</p></dd>
	<dt>FCML_REG_CR</dt>
	<dd><p>Control registers FCML_REG_CR0, FCML_REG_CR2,FCML_REG_CR4 etc.</p></dd>
	<dt>FCML_REG_DR</dt>
	<dd><p>Debug registers FCML_REG_DR0, FCML_REG_DR1, FCML_REG_DR2 etc.</p></dd>
	<dt>FCML_REG_IP</dt>
	<dd><p>Instruction pointer (Used only with RIP addressing.)</p></dd>
</dl>
<p>
	The next two fields stores the register number (See table below.) and its size in bits. You can use the following defines to set appropriate size: <i>FCML_DS_8</i>, <i>FCML_DS_16</i>, <i>FCML_DS_32</i>, <i>FCML_DS_64</i>, <i>FCML_DS_128</i>, <i>FCML_DS_256</i>.
</p>
<p>
	The last field <i>x64_exp</i> is an interesting one. In 64-bit mode in some circumstances processor can not reference following registers: AH, BH, CH, DH. This is an architecture limitation. The overall rule comes down to the fact that they cannot be used when a REX prefix exists for the instruction. Therefore always
	when the REX prefix is available, registers: AH, BH, CH, DH are interpreted as BPL, SPL, DIL, SIL (the low 8 bits for RBP, RSP, RDI and RSI). This field is
	set to <i>FCML_TRUE</i> by the disassembler when the rule affects the register and should be set to <i>FCML_TRUE</i> if we would like to reference these registers while assembling: RBP, RSP, RDI and RSI.
</p>
<p>
The following table shows all supported registers grouped by their types:
</p>
<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<caption>Registers supported by FCML library</caption>
		<thead>
			<tr>
				<th>Type</th>
				<th>Registers</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>8-bit GPR</td>
				<td>
					FCML_REG_AL, FCML_REG_CL, FCML_REG_DL, FCML_REG_DL, FCML_REG_BL, FCML_REG_AH, FCML_REG_SPL, FCML_REG_CH, FCML_REG_BPL, FCML_REG_DH, FCML_REG_SIL, FCML_REG_BH, FCML_REG_DIL, FCML_REG_R8L - FCML_REG_R15L
				</td>
			</tr>
			<tr>
				<td>16-bit GPR</td>
				<td>
					FCML_REG_AX, FCML_REG_CX, FCML_REG_DX, FCML_REG_BX, FCML_REG_SP, FCML_REG_BP, FCML_REG_SI, FCML_REG_DI, FCML_REG_R8W - FCML_REG_R15W 
				</td>
			</tr>
			<tr>
				<td>32-bit GPR</td>
				<td>
					FCML_REG_EAX, FCML_REG_ECX, FCML_REG_EDX, FCML_REG_EBX, FCML_REG_ESP, FCML_REG_EBP, FCML_REG_ESI, FCML_REG_EDI, FCML_REG_R8D - FCML_REG_R15D 
				</td>
			</tr>
			<tr>
				<td>64-bit GPR</td>
				<td>
					FCML_REG_RAX, FCML_REG_RCX, FCML_REG_RDX, FCML_REG_RBX, FCML_REG_RSP, FCML_REG_RBP, FCML_REG_RSI, FCML_REG_RDI, FCML_REG_R8 - FCML_REG_R15
				</td>
			</tr>
			<tr>
				<td>64-bit SIMD (MMX)</td>
				<td>
					FCML_REG_MM0 - FCML_REG_MM7
				</td>
			</tr>
			<tr>
				<td>128-bit SIMD</td>
				<td>
					FCML_REG_XMM0 - FCML_REG_XMM15
				</td>
			</tr>
			<tr>
				<td>256-bit SIMD</td>
				<td>
					FCML_REG_YMM0 - FCML_REG_YMM15
				</td>
			</tr>
			<tr>
				<td>FPU</td>
				<td>
					FCML_REG_ST0 - FCML_REG_ST7
				</td>
			</tr>
			<tr>
				<td>Segment registers</td>
				<td>
					FCML_REG_ES, FCML_REG_CS, FCML_REG_SS, FCML_REG_DS, FCML_REG_FS, FCML_REG_GS
				</td>
			</tr>
			<tr>
				<td>Control registers</td>
				<td>
					FCML_REG_CR0, FCML_REG_CR2, FCML_REG_CR3, FCML_REG_CR4, FCML_REG_CR8
				</td>
			</tr>
			<tr>
				<td>Debug registers</td>
				<td>
					FCML_REG_DR0, FCML_REG_DR1, FCML_REG_DR2, FCML_REG_DR3, FCML_REG_DR4, FCML_REG_DR5, FCML_REG_DR6, FCML_REG_DR7
				</td>
			</tr>
		</tbody>
	</table>
</div>
<div class="notice-box">
Remember that these defines can be used only to specify the register number. They do not describe register size in any way! It is why the register size has to be set in <i>size</i> field anyway.
</div>

<h2 id="un-entry-point">Understanding entry point</h2>
<p>
	The entry point is a structure used widely by FCML library. It is used to define basic information
	about virtual code segments where disassembled/assembled instructions live. It describes such
	things as a processor operating mode, default address and operand size attributes and address of
	instruction in the memory so called "instruction pointer":
</p>
<pre class="brush: cpp">
typedef struct fcml_st_entry_point {
	fcml_en_operating_mode op_mode;
	fcml_usize address_size_attribute;
	fcml_usize operand_size_attribute;
	fcml_ip ip;
} fcml_st_entry_point;
</pre>
<p>
	The entry point structure consists of four fields. The first one <i><a href="api/structfcml__st__entry__point.html#af051b1f4faee0516e00180887e36fc31">op_mode</a></i> is used to configure the processor operating mode and it can be set to one of the following three values:
	<i><a href="api/fcml__common_8h.html#aa842ef70ab3255bbffe239aa2bffdd1b">FCML_OM_16_BIT</a></i>, <i><a href="api/fcml__common_8h.html#aa842ef70ab3255bbffe239aa2bffdd1b">FCML_OM_32_BIT</a></i>, <i><a href="api/fcml__common_8h.html#aa842ef70ab3255bbffe239aa2bffdd1b">FCML_OM_64_BIT</a></i>. They are self-describable, so let's spend a bit more time with the next two fields.
</p>
<p>
	Fields <i><a href="api/structfcml__st__entry__point.html#a813b3746196fe9761c051219d78d28ef">address_size_attribute</a></i> and <i><a href="api/structfcml__st__entry__point.html#a501dccfc67474d305bede649bb5f36cd">operand_size_attribute</a></i> define the default size of the address size
	attribute and the operand size attribute. Such attributes are set for every code segment when the
	processor is executing in the protected mode. The rule is simple. There is a 'D' flag in the segment
	descriptor. This flag specifies the default sizes for the both attributes. When we are in 32 bit mode and 'D' flag
	is 0, both attributes are set to 16 bits. When the flag is set to 1 they both are set to 32 bits. In case of
	64 bit mode if 'D' flag is set to 0 the address size attribute is set to 32 bits and the operand attribute
	size is set to 64 bits. When the flag is set to 1 they both are set to 64 bits. The default values can be
	overridden by the instruction prefixes 0x66, 0x67 and REX. Using the entry point structure we can
	set the default size for operand and address attributes like they were defined by a code segment, but it
	is a bit more flexible because we can set every combination of values, even such which are not
	available in real environments. For instance 16 bit operand size attribute and 32 bit address size
	attribute. If they are set to 0 (<i>FCML_DS_UNDEF</i>), FCML concludes them using chosen <i><a href="api/structfcml__st__entry__point.html#af051b1f4faee0516e00180887e36fc31">op_mode</a></i>
	and supposing that 'D' flag is 0.
</p>
<p>
	The last field <i><a href="api/structfcml__st__entry__point.html#a6826e7ca8aec093a70e710c57dfa756c">ip</a></i> contains a value for the instruction pointer register. In other words, an address in the memory at which the instruction should be located in the code segment. When we are in 16-bit
	mode it is IP register, for 32-bit mode EIP register and RIP register for 64-bit mode.
</p>

<h2 id="dialects">Dialects</h2>
<p>
	Various x86-64 assemblers use different instruction syntaxes to encode their instructions. There are
	two widely used syntax branches. The first one is called the Intel syntax, because it was used in
	Intel's manuals to the x86-64 architecture. The Intel syntax is widely used in Microsoft Windows
	and MS-DOS environments. The second syntax is called AT&amp;T dialect and was created at AT&amp;T
	Bell Labs. It is mainly used in UNIX-like environments. The main differences between these two
	are: the source and destination operand order, the way an operand size is specified, the format of the
	effective address encoding, register naming. For instance the following two instructions represent the same machine
	code using Intel and AT&amp;T dialect:
</p>
<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<caption>One instruction encoded using different dialects</caption>
		<thead>
			<tr>
				<th>Dialect</th>
				<th>Machine code</th>
				<th>Instruction</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>AT&amp;T</td>
				<td><tt>4D11648901</tt></td>
				<td><span class="instruction">adc %r12,0x0000000000000001(%r9,%rcx,4)</span></td>
			</tr>
			<tr>
				<td>Intel</td>
				<td><tt>4D11648901</tt></td>
				<td><span class="instruction">adc qword ptr [r9+rcx*4+0000000000000001h],r12</span></td>
			</tr>
		</tbody>
	</table>
</div>
<p>
	It is out of the scope of the manual to describe all the differences in details, so if you are interested in
	one of these dialects and you would like to learn it, look for documentation that is dedicated to this
	subject.
</p>
<p>
	FCML library provides the abstraction that can be used to add support for almost every existing
	assembler syntax. It is called dialect. Currently FCML supports two main dialects: the Intel dialect
	and the AT&amp;T dialect called also a GAS dialect, because at the moment GNU Assembler (GAS) is in fact the
	reference implementation of the AT&amp;T dialect. In theory the dialect model should be flexible
	enough to implement every existing assembler syntax, but it evolved together with these two
	supported dialects so it is possible that new implementations would have to extend it a bit. Anyway,
	currently there are no plans to support more dialects in the future.
</p>
<p>
	From the user's point of view the dialect is just a syntax they would like to use while
	working with FCML library. Dialects are widely used by almost every function available in the
	library. Even if a function does not need the dialect to be passed to it explicitly it can use it for
	instance implicitly getting it from the assembler or disassembler instance passed to the function.
</p>
<p>
	It is why creating a dialect instance is often the first thing that has to be done when initializing
	FCML library to work.
</p>

<h3 id="dialects-initializing-intel">Initializing Intel dialect</h3>
<p>
	In order to initialize the Intel dialect you have to use the following function, which is available
	inside the <i><a href="api/fcml__intel__dialect_8h.html">fcml_intel_dialect.h</a></i> header file:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_dialect_init_intel( 
	fcml_uint32_t config_flags, 
	fcml_st_dialect **dialect );
</pre>
<p>
	The first argument is not used by the Intel dialect and should be always set to
	FCML_INTEL_DIALECT_CF_DEFAUL. It is used here only in order to make the function declaration
	the same as for the AT&amp;T dialect which can be very useful when we have to store them inside
	function pointers.
</p>
<p>
	The second parameter is an output pointer for the initialized dialect.
</p>
<p>
	If the function succeeded, the return value is set to <i>FCML_CEH_GEC_NO_ERROR</i>.
</p>
<p>
	The following code shows how to initialize the dialect in practice:
</p>
<pre class="brush: cpp">
fcml_st_dialect *dialect;
error = fcml_fn_dialect_init_intel( FCML_GAS_DIALECT_CF_DEFAULT, &dialect );
if( error ) {
	printf( "Cannot initialize the Intel dialect, error: %d\n", error );
	exit(1);
}
</pre>

<h3 id="dialects-initializing-gas">Initializing AT&amp;T (GAS) dialect</h3>
<p>
	Initialization process of the AT&amp;T dialect follows the same convention as the Intel dialect, so we
	have to use the following function, which is defined in <i><a href="api/fcml__gas__dialect_8h.html">fcml_gas_dialect.h</a></i> header file:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_dialect_init_gas( 
	fcml_uint32_t config_flags, 
	fcml_st_dialect **dialect );
</pre>
<p>
	In case of the GAS dialect there is only one flag that can be set in order to configure it. It is
	<i>FCML_GAS_DIALECT_CF_SYSV_SVR32_INCOMPATIBLE</i>, which can be used to disable
	compatibility with the broken implementation of the non-commutative arithmetic floating point
	operations with two register operands introduced in SystemV/386 SVR3.2 assembler and spread
	across the world. If you know nothing about the problem, you definitely want a dialect which is
	fully compatible with the modern GAS implementations, so use <i>FCML_GAS_DIALECT_CF_DEFAULT</i> instead.
</p>
<p>
	The second parameter is an output pointer for an initialized dialect.
</p>
<p>
	If the function succeeds, the return value is set to <i>FCML_CEH_GEC_NO_ERROR</i>.
</p>
<p>
	The following code shows how to initialize the dialect in practice:
</p>
<pre class="brush: cpp">
fcml_st_dialect *dialect;
error = fcml_fn_dialect_init_gas( FCML_GAS_DIALECT_CF_DEFAULT, &dialect );
if( error ) {
	printf( "Can not initialize the AT&amp;T dialect, error: %d\n", error );
	exit(1);
}
</pre>

<h3 id="dialects-disposing">Disposing dialect</h3>
<p>
	Dialects can be treated like singletons and are fully thread safe (in fact they are read only), but
	unfortunately they often allocate some resources internally, like hash maps used to map mnemonics
	to their instruction definitions. It is why they have to be disposed when they are not needed any more. In
	order to do so, use the following function:	
</p>
<pre class="brush: cpp">
	LIB_EXPORT void LIB_CALL fcml_fn_dialect_free(fcml_st_dialect *dialect);
</pre>
<p>
	The following code shows how to dispose the dialect in practice:	
</p>
<pre class="brush: cpp">
	fcml_fn_dialect_free( dialect );
</pre>

<h3 id="dialects-differences">Important differences between dialects</h3>
<p>
	Generic instruction models are dialect dependant. Designing the model to be dialect independent
	was not in the project goals and probably will not be, so if it is for you a must to have feature, be
	aware that this is not possible in case of FCML library. The main arguments against are as follows:
</p>
<ul>
	<li><p>Such a model would be harder to analyse for people who are interested in only one dialect</p></li>
	<li>
		<p>
			There are important differences even in case of instruction mnemonics which makes it
			almost impossible to use instruction codes (which could identify the instructions) in a
			consistent way. POPA instruction is a good example here. In case of the Intel syntax the
			mnemonic POPAD is used when operand size is 32 and mnemonic POPA is used when the
			operand size is 16. So in 32-bit mode the first mnemonic will be assembled to 0x61 and the
			second one to 0x66, 0x61 forcing 16 bits operand size by the use of the appropriate prefix.
			But in case of the AT&amp;T syntax POPA is used when operand-size attribute is 32 and POPAW
			in used for 16 bit operand-size attribute. As you can see there is obvious conflict here. So it
			is definitely more convenient for the programmer to use a mnemonic they are used to rather
			than using the instruction code for instance F_POPA and then specify the needed effective
			operand-size attribute somewhere in the model. (Codes are also provided by
			the disassembler, because they might be more convenient when analysing the code. Especially
			for AT&amp;T assemblers where one instruction may have multiple different mnemonics.)
		</p>
	</li>
	<li>
		<p>
			They differ in the operand order so even if the Intel like ordering would be chosen here it
			would be unnatural for programmers using the AT&amp;T syntax; to say nothing about
			inconsistencies in AT&amp;T assemblers where some instructions use the Intel ordering anyway
			(see: ENTER, BOUND, MONITOR etc.)
		</p>
	</li>
	<li>
		<p>
			There are also other AT&amp;T inconsistencies like broken non-commutative arithmetic floating
			point operations with two register operands (FDIVR instruction encoded using FDIV with
			reverted operands!)
		</p>
	</li>
</ul>
<p>
	Sections bellow describe the most important differences you should be aware of.
</p>

<h4 id="dialects-difs-far-pointers">Far pointers</h4>
<p>
	At first let's see how direct far pointers are used in case of the Intel and AT&amp;T syntaxes:
</p>
<table class="table table-bordered fcml-table">
	<caption>Far pointers encoding by the Intel and AT&amp;T syntax</caption>
	<tbody>
		<tr>
			<td>Intel</td>
			<td><span class="instruction">call far 6655h:44332211h</span></td>
		</tr>
		<tr>
			<td>AT&amp;T</td>
			<td><span class="instruction">lcall $0x6655,$0x44332211</span></td>
		</tr>
	</tbody>
</table>
<p>
	Now let's try to look at these instructions from the parser point of view.
</p>
<p>
	In case of the Intel syntax it is a simple matter. This colon based syntax is dedicated to the far
	pointers so the parser is able to interpret this operand as <i>FCML_OT_FAR_POINTER</i> easily.
</p>
<p>
	The problem appears in case of AT&amp;T parsers, because as you can see there are just two immediate
	integers separated by the comma. The parser is context-less so it is not able to guess that we want
	these operands to be interpreted as one far pointer operand. We also can not make any assumptions
	that these two following immediate integers are always far pointers, because it is simply not true
	(see: ENTER, INSERTQ). So in case of the AT&amp;T syntax they are parsed to two
	<i>FCML_OT_IMMEDIATE</i> operands and then the dialect is responsible for making the correction to
	the model in the preprocessing phase when assembled instruction is already known.
</p>
<p>
	So to sum up:
</p>
<p>
	In case of the Intel dialect you have to provide one <i>FCML_OT_FAR_POINTER</i> operand.
</p>
<p>
	In case of AT&amp;T dialect you can use one <i>FCML_OT_FAR_POINTER</i> operand, but two
	<i>FCML_OT_IMMEDIATE</i> operands will be also interpreted correctly. Anyway, notice that the
	disassembler always disassembles such an addressing mode as one <i>FCML_OT_FAR_POINTER</i>
	operand, so using immediate operands will break the symmetry here. Just treat it as a workaround to
	the ambiguous syntax and do not use it in manually prepared generic instruction models.
</p>

<h4 id="dialects-difs-relative-addresses">Relative addresses</h4>
<p>
	Immediate relative addressing is used in case of branch instructions like CALL or JMP. Let's take a
	look how such instructions are written using the Intel and AT&amp;T syntaxes:
</p>
<table class="table table-bordered fcml-table">
	<caption>How relative jumps are encoded by the Intel and AT&amp;T dialects</caption>
	<tbody>
		<tr>
			<td>Intel</td>
			<td><span class="instruction">jmp 00401001h</span></td>
		</tr>
		<tr>
			<td>AT&amp;T</td>
			<td><span class="instruction">jmp 0x00401001</span></td>
		</tr>
	</tbody>
</table>
<p>
	In case of AT&amp;T everything is simple because it can be easily interpreted as an absolute
	offset (Immediate integers use $ prefix).
</p>
<p>
	The problem appears when it comes to the Intel syntax, because value 00401001h is interpreted as
	an immediate value (<i>FCML_OT_IMMEDIATE</i>) and in fact it is how the Intel parser does its job
	here.
</p>
<p>
	Fortunately, in case of the immediate relative addressing both dialects support
	<i>FCML_OT_IMMEDIATE</i> as well as <i>FCML_OT_ADDRESS</i> (<i>FCML_AF_OFFSET</i>), so both
	GIMs will be properly assembled.
</p>
<p>
	In this case the disassembler does not take the used dialect into account and always returns relative
	addresses as <i>FCML_OT_ADDRESS</i> (<i>FCML_AF_OFFSET</i>) operands. So if you build the GIM
	manually and would like to preserve symmetry you should always use <i>FCML_OT_ADDRESS</i>
	(<i>FCML_AF_OFFSET</i>).
</p>

<h5 id="dialects-dir-ind-addresses">Direct and indirect addresses</h5>
<p>
	The sections below describe some general rules and differences you should be aware of dealing with the direct and indirect
	addressing for branches.
</p>

<h5 id="dialects-dir-ind-addresses-intel">Intel dialect</h5>
<p>
	In case of the Intel dialect indirect near and far addresses for branches are encoded using the
	standard effective addressing pattern. Like in the following examples:
</p>
<pre>
jmp dword [00401001h]
jmp far dword ptr [ebx+00000001h]
</pre>
<p>
	The Intel parser converts these operands to <i>FCML_OT_ADDRESS</i> and everything would be OK if
	there was not a small conflict with the direct immediate relative addressing. As you probably
	already know direct immediate relative addresses can be encoded in two ways using
	<i>FCML_OT_IMMEDIATE</i> and <i>FCML_OT_ADDRESS</i> operands. The first way
	(<i>FCML_OT_IMMEDIATE</i>) is used by the Intel parser (In case of addresses encoded as relative displacement.) and the second one (<i>FCML_OT_ADDRESS</i>) for instance is returned by the disassembler. It is just the problem, the different addressing modes use
	exactly the same way to encode their operands. For example:
</p>
<pre>
jmp dword [00401001h] (indirect)
jmp 00401001h (direct)
</pre>
<p>
	From the GIM point of view both of these instructions can be encoded like this:
</p>
<pre class="brush: cpp">
fcml_st_instruction instruction = {0};
instruction.mnemonic = "jmp";
instruction.operands[0].type = FCML_OT_ADDRESS;
instruction.operands[0].address.address_form = FCML_AF_OFFSET;
instruction.operands[0].address.size_operator = FCML_DS_32;
instruction.operands[0].address.offset.off32 = 0x00401001;
instruction.operands[0].address.offset.size = FCML_DS_32;
instruction.operands_count = 1;
</pre>
<p>
	So how does the assembler distinguish these operands and how does it know which addressing mode
	to choose?
</p>
<p>
	The only way to instruct the assembler which addressing mode should be used is to use one of the
	instruction hints: <i>FCML_HINT_INDIRECT_POINTER</i> or <i>FCML_HINT_DIRECT_POINTER</i>. So
	for example the following instruction will be always assembled using the direct immediate relative
	addressing:	
</p>
<pre class="brush: cpp">
fcml_st_instruction instruction = {0};
instruction.mnemonic = "jmp";
instruction.operands[0].type = FCML_OT_ADDRESS;
instruction.operands[0].address.address_form = FCML_AF_OFFSET;
instruction.operands[0].address.offset.off32 = 0x00401001;
instruction.operands[0].address.offset.size = FCML_DS_32;
instruction.hints |= FCML_HINT_DIRECT_POINTER;
instruction.operands_count = 1;
</pre>
<p>
	In case of the Intel dialect <i>FCML_HINT_INDIRECT_POINTER</i> hint is always the default value in
	case of the described conflict. It is why such instruction "<span class="instruction">jmp dword [00401001h]</span>" will always be
	encoded using indirect memory addressing even if the hint is not present. If you somehow would
	like to encode a direct immediate relative address using such an effective addressing pattern you can
	use a "direct" hint in order to do so (Remember that the Intel parser always encodes direct relative addresses as <i>FCML_OT_IMMEDIATE</i>).
	For instance "<span class="instruction">jmp <b>direct</b> dword [00401001h]</span>”, but take into
	account that it is not the standard way to do so and as such it should not be used anyway. For the
	time of writing, there is only one case where it might be sometimes useful. You can use the
	following notation to force rel16 addressing (16 bit operand size attribute) for the immediate
	relative addressing: "<span class="instruction">jmp direct word [00401001h]</span>", because it cannot be achieved otherwise at
	the moment.
</p>
<p>
	Also notice that in case of the immediate relative addressing, <i><a href="api/structfcml__st__address.html#a992213e47a949d1e80d3cc621efc88ea">size_operator</a></i> can be silently ignored,
	because it is used only to force the specific effective operand size attribute for the instruction (It is
	why the trick above works). So if it is not set, the most relevant effective operand size attribute will
	be chosen (If default optimizer is used.) in respect to the chosen processor operating mode (16, 32,
	64 bits).
</p>
<p>
	Remember that the disassembler always sets appropriate hints, even if they are optional in given
	context in order to avoid potential ambiguities.
</p>

<h4 id="dialects-dir-ind-addresses-gas">AT&amp;T dialect</h4>
<p>
	In case of the AT&amp;T dialect indirect addressing for branches as well as the direct relative addressing
	are encoded using the standard effective addressing pattern. Like in the following examples:
</p>
<pre>
jmp 0x90d11004
jmp *0x90d11004
</pre>
<p>
	Unlike the Intel dialect, the AT&amp;T parser converts both of these forms to the
	FCML_OT_ADDRESS operands. This rule follows the standard AT&amp;T syntax so everything is
	consistent here. For the AT&amp;T dialect we will never get a direct relative address encoded as
	FCML_OT_IMMEDIATE operand. Of course the disassembler supports it anyway, but you should
	never use it in practice, because it is unnatural for the AT&amp;T syntax. To say nothing of the symmetry.
</p>
<p>
	Like in the Intel dialect there is also a conflict here, because both of these instructions are encoded
	to the same GIM. Fortunately, even if there is a conflict on the operand level the both instructions
	are not ambiguous at all due to the used indirect operator. So in fact the AT&amp;T parser will always
	set <i>FCML_HINT_INDIRECT_POINTER</i> hint for the second instruction and everything would be
	OK if we were using only the parser to build general instruction models. The problem appears when
	we would like to use manually prepared GIM, because in order to avoid conflicts we have to use
	hints for both addressing modes. The direct relative immediate addressing needs
	<i>FCML_HINT_DIRECT_POINTER</i> hint whereas the indirect memory addressing is forced using
	<i>FCML_HINT_INDIRECT_POINTER</i> hint. To be consistent the AT&amp;T dialect uses
	<i>FCML_HINT_DIRECT_POINTER</i> hint as the default hint for the branches which use direct
	relative addresses, so you have to set <i>FCML_HINT_INDIRECT_POINTER</i> hint only in order to
	force indirect addressing.
</p>
<p>
	The AT&amp;T disassembler always sets appropriate hints for both operating modes in order to avoid
	potential ambiguities.
</p>

<h2 id="data-types">Data types</h2>
<p>
	The header file fcml_types.h defines all simple types and their nullable counterparts used by the
	implementation of the FCML library. These types are also used by structures and functions being
	part of the library interface, so you should take a look at them:
</p>
<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<caption>Simple data types supported by FCML</caption>
		<thead>
			<tr>
				<th>Type</th>
				<th>Size</th>
				<th>Description</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>fcml_char</td>
				<td>8 bits</td>
				<td>One ASCII character.</td>
			</tr>
			<tr>
				<td>fcml_string</td>
				<td>variable</td>
				<td>An array of ASCII characters.</td>
			</tr>
			<tr>
				<td>fcml_float</td>
				<td>32 bits</td>
				<td>Float values (Not used yet, reserved for future use.).</td>
			</tr>
			<tr>
				<td>fcml_usize</td>
				<td>32 bits</td>
				<td>Data type for all unsigned sizes.</td>
			</tr>
			<tr>
				<td>fcml_size</td>
				<td>32 bits</td>
				<td>Data type for all signed sizes.</td>
			</tr>
			<tr>
				<td>fcml_flags</td>
				<td>32 bits</td>
				<td>Data types for flags based of bit masks.</td>
			</tr>
			<tr>
				<td>fcml_int</td>
				<td>Architecture dependent</td>
				<td>Counterpart of the standard int type.</td>
			</tr>
			<tr>
				<td>fcml_bool</td>
				<td>Architecture dependent</td>
				<td>Boolean data type. Possible values: FCML_TRUE, FCML_FALSE.</td>
			</tr>
			<tr>
				<td>fcml_int8_t</td>
				<td>8 bits</td>
				<td>A signed 8 bits integer.</td>
			</tr>
			<tr>
				<td>fcml_uint8_t</td>
				<td>8 bits</td>
				<td>An unsigned 8 bits integer.</td>
			</tr>
			<tr>
				<td>fcml_int16_t</td>
				<td>16 bits</td>
				<td>A signed 16 bits integer.</td>
			</tr>
			<tr>
				<td>fcml_uint16_t</td>
				<td>16 bits</td>
				<td>An unsigned 16 bits integer.</td>
			</tr>
			<tr>
				<td>fcml_int32_t</td>
				<td>32 bits</td>
				<td>A signed 32 bits integer.</td>
			</tr>
			<tr>
				<td>fcml_uint32_t</td>
				<td>32 bits</td>
				<td>An unsigned 32 bits integer.</td>
			</tr>
			<tr>
				<td>fcml_int64_t</td>
				<td>64 bits</td>
				<td>A signed 64 bits integer.</td>
			</tr>
			<tr>
				<td>fcml_uint64_t</td>
				<td>64 bits</td>
				<td>An unsigned 64 bits integer.</td>
			</tr>
			
		</tbody>
	</table>
</div>
<p>
	Every integer type other than <i>fcml_int</i> has a nullable counterpart. They are structures which consist
	of an integer value itself and a boolean field indicating whether the value is set or not. For
	example:
</p>
<pre class="brush: cpp">
typedef struct fcml_nuint32_t {
	fcml_uint32_t value;
	fcml_bool is_not_null;
} fcml_nuint32_t;
</pre>
<p>
	There is one more important complex data type <i>fcml_st_integer</i>. It is a general purpose container for integer
	values that also holds the size and sign of the integer value:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_integer {
	fcml_data_size size;
	fcml_bool is_signed;
	fcml_int8_t int8;
	fcml_int16_t int16;
	fcml_int32_t int32;
	fcml_int64_t int64;
} fcml_st_integer;
</pre>
<p>
	There are also constants with limits for integer values as well as patterns for text formatting
	functions from standard I/O libraries, see <i><a href="api/fcml__types_8h_source.html">fcml_types.h</a></i> for more details.
</p>

<h2 id="error-handling">Error handling</h2>
<p>
	The whole FCML library consistently follows the same error handling convention. All structures
	functions and macros dedicated for error handling are defined inside <i><a href="api/fcml__errors_8h.html">fcml_errors.h</a></i> header file. The
	most commonly used data type is without a doubt <i><a href="api/fcml__errors_8h.html#a5dc52a6ee90a57e58a0760296b0c36e3">fcml_ceh_error</a></i>.
	It is used to return an error code from almost every FCML library function. The possible error codes are defined by
	<i><a href="api/group__ERRORS__GROUP.html#ga88406cc59b708d9f4de9286d254dd10a">fcml_en_ceh_error_globals</a></i> 
	enumeration which can be found inside <i><a href="api/fcml__errors_8h.html">fcml_errors.h</a></i> header file.
</p>
<p>
	There is also another enumeration <i><a href="api/group__MESSAGE__ERRORS__GROUP.html#gab7c94675e299cea120e12c4bffd48905q">fcml_en_ceh_message_errors</a></i> which contains error codes
	dedicated for textual messages. The global error codes can be also used as message error codes and
	it is why they use different ranges.
</p>
<p>
	The main structure behind error handling is <i><a href="api/structfcml__st__ceh__error__container.html">fcml_st_ceh_error_container</a></i> which is a container that holds one or more textual error messages:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_ceh_error_container {
	fcml_st_ceh_error_info *errors;
	fcml_st_ceh_error_info *last_error;
} fcml_st_ceh_error_container;
</pre>
<p>
	The field <i><a href="api/structfcml__st__ceh__error__container.html#a316e5c0e71db3fb120da932485513710">errors</a></i> points to the first error available in the container. If the container is empty it is set to NULL. The next field <i><a href="api/structfcml__st__ceh__error__container.html#a9727e3471e98c15e520189d1ac56d698">last_errors</a></i> points to the last error on the list. The following structure
	describes one error message:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_ceh_error_info {
	struct fcml_st_ceh_error_info *next_error;
	fcml_string message;
	fcml_ceh_error code;
	fcml_en_ceh_error_level level;
} fcml_st_ceh_error_info;
</pre>
<p>
	The first field <i><a href="api/structfcml__st__ceh__error__info.html#a8603e1303f0ae6414c621675be2611cc">next_error</a></i> points to the next error on the list. For the last one it is set to NULL. The field <i><a href="api/structfcml__st__ceh__error__info.html#adca459dd38acc140af59938ccb7858ff">message</a></i> contains textual representation of the error whose code is available in the <i><a href="api/structfcml__st__ceh__error__info.html#aba82165386486b412b07fa34c0475057">code</a></i> field. Every error message has also a level associated with it. Currently there are two supported levels: <i>FCML_EN_CEH_EL_WARN</i> and <i>FCML_EN_CEH_EL_ERROR</i>. The first is destined for warning messages which might be returned even if a given function ended with success and the second one is for critical errors. 
</p>
<p>
	There are also dedicated error codes for warnings, take a look at <i><a href="api/fcml__errors_8h.html">fcml_errors.h</a></i> for more details.
</p>

<h2 id="configuring-environment">Configuring environment</h2>
<p>
	The header file <i><a href="api/fcml__env_8h.html">fcml_env.h</a></i> declares three functions that can be used to register dedicated handlers for memory management subsystem. By registering them you can provide your own implementation of the functions which allocate memory blocks, reallocate them and free the ones that are not needed any more. Every internal FCML component (Even Flex lexical analysers and Bison parsers) uses these handlers to manage the memory heap, so after changing them you should not see any direct calls to the standard heap management functions like <i>malloc</i> or <i>free</i>. 
</p>
<p>
	In order to register a new handler you have to prepare the implementation first. To do so you have
	to implement functions that match the following function declarations:
</p>
<pre class="brush: cpp">
typedef fcml_ptr (*fcml_fp_env_memory_alloc_handler)( fcml_usize size );
typedef fcml_ptr (*fcml_fp_env_memory_realloc_handler)( fcml_ptr ptr, fcml_usize size );
typedef void (*fcml_fp_env_memory_free_handler)( fcml_ptr memory_block );
</pre>
<p>
	Then you have to use the following functions to register the new handlers:
</p>
<pre class="brush: cpp">
fcml_fp_env_memory_alloc_handler fcml_fn_env_register_memory_alloc_handler(
	fcml_fp_env_memory_alloc_handler handler );
fcml_fp_env_memory_realloc_handler fcml_fn_env_register_memory_realloc_handler(
	fcml_fp_env_memory_realloc_handler handler );
fcml_fp_env_memory_free_handler fcml_fn_env_register_memory_free_handler(
	fcml_fp_env_memory_free_handler handler );
</pre>
<p>
	So for example, in order to register a new handler for the memory allocation function you should call the <i><a href="api/fcml__env_8h.html#aba4db30e82402d66e74fdc5980abf02d">fcml_fn_env_register_memory_alloc_handler</a></i> function passing the pointer to the new handler implementation as the function parameter. As a result the function returns the pointer to the old allocation handler so you can use it to restore the original handler if needed. The working example is available in "check/internal-tests/env_t.c" unit test. 
</p>

<h2 id="pseudo-operations">Pseudo operations</h2>
<p>
	A pseudo-operation is an instruction to the assembler that does not generate any machine code.
	Every pseudo operation has its own independent and dedicated implementation. Currently only one
	pseudo operation is supported by FCML. It is <span class="instruction">db</span> in case of the Intel dialect and <span class="instruction">.byte</span> for the GAS. This operation was added only in order to handle unknown instructions properly. So if the
	disassembler configuration field <i><a href="api/structfcml__st__disassembler__conf.html#aa514b85fe6790a19573dde68d5e0d048">fail_if_unknown_instruction</a></i> is set to <i>FCML_FALSE</i>, instead of returning the <i>FCML_CEH_GEC_UNKNOWN_INSTRUCTION</i> the <span class="instruction">db</span>/<span class="instruction">.byte</span> pseudo operation is
	generated for the current byte. In both cases the instruction is encoded using the instruction
	mnemonic and one operand of the type <i>FCML_OT_IMMEDIATE</i> (8 bits). The following examples
	show syntaxes for the both dialects:
</p>
<table class="table table-bordered fcml-table">
	<caption>Pseudo operation</caption>
	<tbody>
		<tr>
			<td>AT&amp;T</td>
			<td><span class="instruction">label: .byte 0x12</span></td>
		</tr>
		<tr>
			<td>Intel</td>
			<td><span class="instruction">label: db 0x12</span></td>
		</tr>
	</tbody>
</table>
<p>
	The instruction label is of course optional and can be ignored.
</p>

<h2 id="symbols">Symbols</h2>
<p>
	Symbols are used by parsers in place of constant values and to declare instruction labels. Generic instruction models need all values explicitly set, so all symbols have to be resolved on the parser layer. It is why the symbol tables are available only in the <i><a href="api/structfcml__st__parser__context.html">fcml_st_parser_context</a></i> and <i><a href="api/structfcml__st__lag__assembler__context.html">fcml_st_lag_assembler_context</a></i> structures (Remember that the multi-pass load-and-go assembler works with textual instructions, so they have to be parsed as well). The following example shows the proper way to use symbols: 
</p>
<pre>
label: adc eax, ( 128 + MAX_PATH ) * FACTOR
</pre>
<p>
	As you can see there are three symbols used. The first one "label" is a symbol declaration. The second and the third are used as constant values. 
</p>
<p>
	The main structure behind symbols is the symbol itself represented as the <i><a href="api/structfcml__st__symbol.html">fcml_st_symbol</a></i> structure and the data type <i><a href="api/fcml__symbols_8h.html#a99c60a6da2f9df70d4b61133e2db403b">fcml_st_symbol_table</a></i> used to represent the symbol table. The symbol table is used to exchange symbols with parsers. 
</p>
<p>
	First of all let's take a look at the <i><a href="api/structfcml__st__symbol.html">fcml_st_symbol</a></i> structure:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_symbol {
	fcml_string symbol;
	fcml_int64_t value;
} fcml_st_symbol;
</pre>
<p>
	The first field stores a symbol name. The second field holds a symbol value. As it is described in the <i><a href="#parser">chapter about parsers</a></i>, every parser works on 64-bit values. It is why the symbol value has 64 bits here. 
</p>
<p>
	The symbol table can be used in both directions. It means that you can use it in order to declare constants for the parser and to access labels declared by the parser. For more information about using symbols together with parsers do not hesitate to take a look at the <i><a href="#parser">Parser</a></i> chapter.
</p>
<p>
	For now, let's try to create our first symbol table and to declare the two symbols that have been used in the example above. 
</p>
<p>
	In order to create a new symbol table you have to use the <i><a href="api/fcml__symbols_8h.html#a3275e1e9009808ba96804245c4c0c5e4">fcml_fn_symbol_table_alloc</a></i> function: 
</p>
<pre class="brush: cpp">
	LIB_EXPORT fcml_st_symbol_table LIB_CALL fcml_fn_symbol_table_alloc();
</pre>
<p>
	For instance having initialized the parser context you can declare it like this:
</p>
<pre class="brush: cpp">
fcml_st_parser_context context = {0};
…
context.symbol_table = fcml_fn_symbol_table_alloc();
</pre>
<p>
	Of course you should check if the function succeeded, because it may return a NULL in case of a lack of memory. 
</p>
<p>
	Now feel free to add as much symbols as you want to the table, but you have to know one more important thing before allocating anything. 
</p>
<p>
	Every symbol should be allocated by the dedicated function <i><a href="api/fcml__symbols_8h.html#a7ce4c5448ba9745948d26e27d5a42992">fcml_fn_symbol_alloc</a></i>. It is really important as long as you would like to use standard functions like <i><a href="api/fcml__symbols_8h.html#a9f7a09b8ef16e0ab9fc80ee3e7e032a3">fcml_fn_symbol_remove_all</a></i> or <i><a href="api/fcml__symbols_8h.html#a58949526e7cdfbbcf8483937b1ab9b0e">fcml_fn_symbol_table_free</a></i> to free symbols, because they have to use the same shared heap. It is especially important in case of windows binaries which were statically linked with standard libraries. 
</p>
<p>
	The declaration of the mentioned function:
</p>
<pre class="brush: cpp">
fcml_st_symbol* LIB_CALL fcml_fn_symbol_alloc( 
	fcml_string symbol_name, 
	fcml_int64_t value )
</pre>
<p>
	The function gets a symbol name and a symbol value as parameters and returns the allocated symbol. The symbol name is duplicated and can be safely freed as soon as the function finishes. 
</p>
<p>
	OK, we know how to allocate the symbol table and the symbols themselves. Now let's try to add the new symbol to the symbol table. In order to do so you have to use the following function: 
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_symbol_add( 
	fcml_st_symbol_table symbol_table, 
	fcml_st_symbol *symbol );
</pre>
<p>
	It adds a symbol to a symbol table passed in the first parameter.
</p>
<p>
	Alternatively you may consider the use of the <i><a href="api/fcml__symbols_8h.html#aeb1ec9bc264565c9333c90e9e5663fde">fcml_fn_symbol_add_raw</a></i> function which allocates a new symbol and adds it to a symbol table in one step: 
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_symbol_add_raw( 
	fcml_st_symbol_table symbol_table, 
	fcml_string symbol,
	fcml_int64_t value );
</pre>
<p>
	The first parameter is the destination symbol table. The second parameter is the symbol name and the last one is the symbol value. Every symbol name is duplicated so feel free to deallocate it as soon as the function returns. If the function succeeds <i>FCML_CEH_GEC_NO_ERROR</i> is returned. 
</p>
<p>
	Allocating the constant values from the example above (Without error handling):
</p>
<pre class="brush: cpp">
fcml_st_symbol_table table = fcml_fn_symbol_table_alloc();
fcml_st_symbol *symbol = fcml_fn_symbol_alloc( "MAX_PATH", 256 );
fcml_fn_symbol_add( table, symbol )
symbol = fcml_fn_symbol_alloc( "FACTOR", 2 );
fcml_fn_symbol_add( table, symbol );
</pre>
<p>
	For now we know how to allocate and fill a symbol table with symbols, but what if we would like to get a label declared by the parser? It is quite easy. There is a function <i><a href="api/fcml__symbols_8h.html#a6cc6a122923703f305981c4aa605b08e">fcml_fn_symbol_get</a></i> which can be used to retrieve every symbol from a symbol table: 
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_st_symbol* LIB_CALL fcml_fn_symbol_get( 
	fcml_st_symbol_table symbol_table, 
	fcml_string symbol );
</pre>
<p>
	It gets a symbol table and a symbol name as parameters and returns the corresponding symbol or NULL if there is no such symbol in the symbol table. 
</p>
<p>
	There is one more useful function that can be used to manipulate symbol tables. It is <i><a href="api/fcml__symbols_8h.html#ae5b58e05909d168f8e06ef43f9be05c5">fcml_fn_symbol_remove</a></i> which removes a symbol of matching name from a symbol table. It only removes the symbol from the symbol table, but does not free it in any way: 
</p>
<pre class="brush: cpp">
	LIB_EXPORT void LIB_CALL fcml_fn_symbol_remove( 
		fcml_st_symbol_table symbol_table,
		fcml_string symbol );
</pre>
<p>
	If you would like to free it manually you have to use a different function:
</p>
<pre class="brush: cpp">
LIB_EXPORT void LIB_CALL fcml_fn_symbol_free( fcml_st_symbol *symbol );
</pre>
<p>
	When a symbol table is not needed any more it should be freed. In order to do so you can use the <i><a href="api/fcml__symbols_8h.html#a58949526e7cdfbbcf8483937b1ab9b0e">fcml_fn_symbol_table_free</a></i> function which frees all symbols available in the symbol table and then deallocates the symbol table itself. 
</p>
<p>
	You can also clean a symbol table by freeing all symbols available in it using the <i><a href="api/fcml__symbols_8h.html#a9f7a09b8ef16e0ab9fc80ee3e7e032a3">fcml_fn_symbol_remove_all</a></i> function: 
</p>
<pre class="brush: cpp">
LIB_EXPORT void LIB_CALL fcml_fn_symbol_remove_all( 
	fcml_st_symbol_table symbol_table );
</pre>

<h2 id="assembler">Assembler</h2>

<p>
	The FCML assembler is an one-line load-and-go assembler implementation. It means that it is able to generate the machine code even directly to a real code segment where it can be then executed. It also means that it generates the machine code only, so you cannot generate the whole executable file with all headers and chunks using the library. 
</p>
<p>
	The FCML assembler works with the GIM (see: <a href="#generic_instruction_model">Generic instruction model</a>), so in order to assemble anything you are obliged to prepare the correct GIM and then pass it to the assembler. Such a solution has the following advantages:
</p>
<ul>
	<li><p>You are able to build instructions in a dynamic manner and it is more convenient than simple string concatenation.</p></li>
	<li>
		<p>
			You are able to disassemble a piece of machine code directly to the GIM, analyse it, then for instance you may decide to change the offset of a branch instruction and pass such a modified GIM directly to the assembler to assemble it back. If instructions were represented as strings it would be pretty close to being impossible, or at least really hard to achieve :)
		</p>
	</li>
	<li>
		<p>
			You can parse an instruction to the GIM, analyse it (for example to check if the user tried to use a restricted register for example.) and then pass such a verified model to the assembler.
		<p/>
	</li>
</ul>

<h3 id="assembler-initialization">Initializing assembler instance</h3>
<p>
	In order to prepare the assembler to work it needs to be initialized with an instance of the dialect (see: <a href="#dialects">Dialects</a>), hence it is a time to take a look at the initialization function provided by the FCML library:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_assembler_init( 
	fcml_st_dialect *context, 
	fcml_st_assembler **assembler );
</pre>
<p>
	After the function is successfully invoked the <i>assembler</i> parameter points to the initialized assembler.
</p>
<p>
	Notice that every assembler instance is thread-safe, hence it can be used across many independent threads, but initialization should be synchronized as long as the <i>assembler</i> parameter points to a shared pointer.
</p>
<p>
	Every instance of the assembler should be freed when it is no longer needed. We are able to achieve that using the following function:
</p>
<pre class="brush: cpp">
LIB_EXPORT void LIB_CALL fcml_fn_assembler_free( 
	fcml_st_assembler *assembler );
</pre>
<p>
	Just pass the assembler instance as the function parameter and that is all. 
</p>
<p>
	There is one more thing that should be pointed out here. In the paragraph above you learnt that assemblers are thread-safe and their instances can be safely shared across independent threads and that initialization has to be synchronized when we would like to initialize only one assembler instance for multiple threads. This rule is also true in case of the assembler freeing process, which also has to be synchronized. So it should be enough to remember that only the <i><a href="api/fcml__assembler_8h.html#a232c49ae5936be24d990a5a012a63e78">fcml_fn_assemble</a></i> function which shares an assembler instance is really thread-safe.
</p>
<p>
	The best pattern for multi-threaded environment is to initialize an assembler instance on the main thread, then use multiple independent working threads to share the assembler and at the end when working threads are dead, free the assembler using the main thread again.
</p>
<p>
	Initialization example:
</p>
<pre class="brush: cpp">
fcml_st_assembler *assembler;
fcml_ceh_error error = fcml_fn_assembler_init( dialect, &amp;assembler );
if( error ) {
	printf("Can not initialize the assembler: error %d.\n", error);
	exit(1);
}
fcml_fn_assembler_free( assembler );
</pre>

<h3 id="assembler-assembling">Assembling generic instruction model</h3>
<p>
When we already have an assembler instance initialized, we can use it to assemble an example GIM. In order to do so, we have to use the following function:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_assemble( 
	fcml_st_assembler_context *context, 
	const fcml_st_instruction *instruction, 
	fcml_st_assembler_result *result );
</pre>
<p>
	As you can see it gets three parameters. The first one is an assembler context which contains some information about the environment as well as the assembler configuration that should be used to assemble one instruction. The second parameter is the generic instruction model describing an instruction and the last one is a place where the assembler puts all the results. So let's start with the assembler context first.
</p>

<h4 id="asm-ctx">Assembler context</h4>
<p>
	An assembler context holds information about the environment. It tells FCML which assembler instance it should use to assemble the instruction code, an assembler configuration to be used while assembling the instruction and an entry point describing a virtual code segment (see: <a href="#un-entry-point">Understanding entry point</a>). The context is reusable and can be shared between multiple function calls, but it should not be used across multiple threads, mainly due to the consistency with the disassembler and the fact that the assembler can modify the entry point in some circumstances. Take a look at the <i><a href="api/structfcml__st__assembler__context.html">fcml_st_assembler_context</a></i> structure declaration:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_assembler_context {
    fcml_st_assembler *assembler;
    fcml_st_assembler_conf configuration;
    fcml_st_entry_point entry_point;
} fcml_st_assembler_context;
</pre>
<p>
	The first property <i><a href="api/structfcml__st__assembler__context.html#a6c34722431406eb44d620b700f69e7d2">assembler</a></i> has to be set to the initialized assembler instance. The second property <i><a href="api/structfcml__st__assembler__context.html#a88b1f8e6449ba3d5d56c31717d3603b3">configuration</a></i> consists of all configuration properties. The <i><a href="api/structfcml__st__assembler__conf.html">fcml_st_assembler_conf</a></i> structure declaration is available in the <i><a href="api/fcml__assembler_8h.html">fcml_assembler.h</a></i> header file and is well documented there, so let's focus on the properties it defines only:
</p>
<dl class="dl-asm-conf-horizontal">
	<dt>increment_ip</dt>
	<dd>
		<p>
			Set to true if you would like the <i><a href="api/structfcml__st__entry__point.html#a6826e7ca8aec093a70e710c57dfa756c">instruction pointer</a></i> to be incremented after an instruction is assembled. It is incremented by the length of the assembled instruction chosen as a best option (By the <i><a href="#asm-choosers">instruction chooser</a></i>). It can be very useful when we are assembling multiple instructions (which follow each other) one by one using the same assembler context.
		</p>
	</dd>
	<dt>enable_error_messages</dt>
	<dd>
		<p>
			Set to true if you want textual error messages to be generated (See: <i><a href="#error-handling">Error handling</a></i>).
		</p>
	</dd>
	<dt>choose_sib_encoding</dt>
	<dd>
		<p>
			It is rarely a useful option. It tells the assembler to encode the ModR/M byte together with the SIB byte even if it is optional in a certain case. In the day-to-day usage it should be always set to <i>FCML_FALSE</i>.
		</p>
	</dd>
	<dt>choose_abs_encoding</dt>
	<dd>
		<p>
			It is useful in case of the 64-bit processor operating mode. If it is set to <i>FCML_TRUE</i> it disables the RIP addressing and forces the assembler to encode addresses as absolute offsets; otherwise it tells the assembler to use the RIP addressing and to encode addresses as displacements relative to the instruction pointer.
		</p>
	</dd>
	<dt>force_rex_prefix</dt>
	<dd>
		<p>
			Sometimes the REX prefix is useless so it is just omitted in the final machine code. By setting this field to <i>FCML_TRUE</i> you can force the REX prefix to be added anyway. In the day-to-day usage it should be always set to <i>FCML_FALSE</i>.
		</p>
	</dd>
	<dt>force_three_byte_VEX</dt>
	<dd>
		<p>
			The assembler always chooses the shortest form of the VEX/XOP prefixes an instruction can be encoded with, however by setting this field to <i>FCML_TRUE</i> you can force the assembler to always encode this prefix on three bytes. In the day-to-day usage it should be always set to <i>FCML_FALSE</i>.
		</p>
	</dd>
	<dt>optimizer</dt>
	<dd>
		<p>
			This field allows us to set a custom optimizer that should be used by the assembler (See: <i><a href="#asm-optimizers">Optimizers</a></i>). Setting this property to <i>NULL</i> results in choosing the default optimizer implementation.
		</p>
	</dd>
	<dt>optimizer_flags</dt>
	<dd>
		<p>
			Optional flags which will be passed to the optimizer.
		</p>
	</dd>
	<dt>chooser</dt>
	<dd>
		<p>
			This field defines a custom instruction chooser (See: <i><a href="#asm-choosers">Instruction choosers</a></i>). Setting this property to <i>NULL</i> results in choosing the default chooser implementation.
		</p>
	</dd>
</dl>
<p>
	Looking at these configuration properties you might be under the impression that there are only two configuration properties which are really useful if you do not need any special power and it is of course true. In the day-to-day usage the configuration should look something like this, according to your need:
</p>
<pre class="brush: cpp">
context.configuration.increment_ip = FCML_TRUE;
context.configuration.enable_error_messages = FCML_TRUE;
</pre>
<p>
	The last property inside the assembler context is the <i><a href="api/structfcml__st__assembler__context.html#a69a3b4598fd34435012827fedad4c217">entry_point</a></i>. This structure is widely used across the FCML library and has its own chapter, so do not hesitate to take a look at it (<i><a href="#un-entry-point">Understanding entry point</a></i>).
</p>


<h4 id="asm-optimizers">Optimizers</h4>
<p>
	To explain it in simple terms we need an example here. So let's take a look at this instruction: "<span class="instruction">call qword ptr [rdi+1h]</span>", which should be assembled to the following code: <tt>0xFF5701</tt>. 
</p>
<p>
	Although the effective operand size attribute is always forced to 64 bits for this instruction, we still can try to force the 16-bit operand size using <tt>0x66</tt> prefix: <tt>0x<b>66</b>FF5701</tt>, or even combine it with the optional REX.W set to the 1 (What is not necessary because the 64-bit operand size attribute is forced anyway):  <tt>0x<b>6648</b>FF5701</tt>. Of course despite the fact that these encodings are perfectly allowed, they are superfluous and can even hit the performance. In general optimizers are responsible for choosing the best combination of the effective operand size attribute and effective address size attribute to be used for assembled instructions. It is a bit more advanced subject and you definitely should spend a little while analysing the <i><a href="api/fcml__optimizers_8h.html">fcml_optimizers.h</a></i> header file and the default optimizer implementation <i><a href="api/fcml__optimizers_8h.html#a57d7fd22085d3209af68a54d77b2466f">fcml_fn_asm_default_optimizer</a></i> if you do really need to write your own optimizer.
</p>

<h4 id="asm-choosers">Instruction choosers</h4>
<p>
	As you probably already know, assemblers are able to assemble instructions to more than one piece of the machine code. If there are any alternatives it is up to the instruction chooser to choose the most relevant piece of the machine code and mark it for the user. The default implementation returns just the shortest instruction form available, so it is a pretty simple implementation. If you would like to implement your own instruction chooser, do not hesitate to take a look at the <i><a href="api/fcml__choosers_8h.html">fcml_choosers.h</a></i> header file and the default implementation itself: <i><a href="api/fcml__choosers_8h.html#a03e72ffd9de5fe9bdc0b33bc3cfa73f4">fcml_fn_asm_default_instruction_chooser</a></i>. Currently there is no context available yet for the choosers, so everything you can analyse to make the decision is the machine code itself. It is a bit limited for the moment and  the API probably will be extended in the future.
</p>

<h4 id="asm-result">Preparing assembler result</h4>
<p>
	Every invocation of the assembler needs to return a piece of assembled code as the result. The structure <i><a href="api/structfcml__st__assembler__result.html">fcml_st_assembler_result</a></i> is a container for anything that assembler can produce:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_assembler_result {
	fcml_st_ceh_error_container errors;
	fcml_st_assembled_instruction *instructions;
	fcml_st_assembled_instruction *chosen_instruction;
	fcml_usize number_of_instructions;
} fcml_st_assembler_result;
</pre>
<p>
	The first field contains textual errors with the reason of the failure. It also may contain warning messages which might be available there even if the function succeeded. The remaining fields hold information about assembled instructions. The field <i><a href="api/structfcml__st__assembler__result.html#af1cf24376d422a24779672c606159ee1">instructions</a></i> points to the head of the instruction chain. The best instruction chosen by the assembler (See: <i><a href="#asm-choosers">Instruction choosers</a></i>) is returned in the <i><a href="api/structfcml__st__assembler__result.html#a1530e7b03cb76c98bbf37c8e26c3e966">chosen_instruction</a></i> field and the number of available instructions is available in the last <i><a href="api/structfcml__st__assembler__result.html#aecbfe1ddb4d62b22ac942166969fc83f">number_of_instructions</a></i> field.
</p>
<p>
	The most interesting thing here is the assembled instruction itself, so let's take a look at the <i><a href="api/structfcml__st__assembled__instruction.html">fcml_st_assembled_instruction</a></i> structure:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_assembled_instruction {
    struct fcml_st_assembled_instruction *next;
    fcml_st_ceh_error_container warnings;
    fcml_uint8_t *code;
    fcml_usize code_length;
} fcml_st_assembled_instruction;
</pre>
<p>
	As you can see there are warnings related to the assembled instruction and the pointer to the next instruction in the chain, but it is the machine code what is the most important for us. The field <i><a href="api/structfcml__st__assembled__instruction.html#aabe970d16e617b157ab0360538c5278f">code</a></i> points to the machine code representation of the assembled instruction and <i><a href="api/structfcml__st__assembled__instruction.html#a1b47c6d378eb5ecd049023eeb1d604c3">code_length</a></i> is the length of the machine code in bytes. 
</p>
<p>
	Now we know how the structures are organized, so it is time to pay some attention to the general usage, but at first let's take a look at the declaration of the assembling function again:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_assemble( 
	fcml_st_assembler_context *context, 
	const fcml_st_instruction *instruction, 
	fcml_st_assembler_result *result );
</pre>
<p>
	As you can see the assembler result is just a pointer to the result structure, so it cannot be allocated and returned by the assembler. Surely the function could be implemented to return a pointer to the pointer of the result which then would be used by the assembler to return a newly allocated structure by every invocation. Such a solution would be at least impractical, because you would be obliged to free this structure after every invocation of the assembler and it could not be reused in any way. Hence to avoid unnecessary allocations and deallocations, a reusable structure is used here. You can prepare only one assembler result and use it for every invocation of the assembler within one thread.
</p>
<p>
	Of course the structure holds memory regions allocated by the assembler that have to be freed anyway, but it is done transparently by the assembler itself, so when the assembler gets the same structure again it checks if there is something allocated in it and deallocates everything in order to prepare it for the new assembling process (warnings, assembled instructions). You have to deallocate it on your own but only when it is not needed any more. In such a case you are obligated to free the result of the last assembling process using the <i><a href="api/fcml__assembler_8h.html#af7c11065d9016903daf8ae0a3b1d4d74">fcml_fn_assembler_result_free</a></i> function. Remember that this function is responsible for freeing all internal structures, but the main container is certainly still valid and you are responsible for freeing it (or even reusing it again). So anyway, when we call the assembler the first time it checks the result and tries to deallocate everything it finds there. It can be a bit dangerous process for uninitialized structures cause of potential rubbish there. It is why the assembler result has to be prepared for the first call. It is the <i><a href="api/fcml__assembler_8h.html#a3a827d482043c2fc1c6766e71f047484">fcml_fn_assembler_result_prepare</a></i> function which is responsible for preparing it for the first call. 
</p>
<p>
	To sum up, let's take a look at the following piece of code. It shows the pattern we should follow when working with the result structure:
</p>
<pre class="brush: cpp">
fcml_st_disassembler_result result;
fcml_fn_disassembler_result_prepare( &amp;result );
while(...) {
    fcml_fn_assemble( &amp;asm_context, &amp;instruction, &amp;asm_result );
    ...
}
fcml_fn_assembler_result_free( &amp;asm_result );
</pre>
<div class="notice-box">
	Notice that: You have to copy the machine code of an assembled instruction if you need it later, because it will be deallocated by the next call to the assembler.
</div>
<p>
	Although the assembler result structure is reusable it should be remembered that it cannot be used across multiple threads at the same time, because it may lead from memory loss to event unexpected crashes due to memory corruption.
</p>


<h4 id="asm-invoke">Invoking assembler</h4>
<p>
	Until now, we have prepared all instruction parameters, so let's see the assembling function declaration again:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_assemble( 
	fcml_st_assembler_context *context, 
	const fcml_st_instruction *instruction, 
	fcml_st_assembler_result *result );
</pre>
<p>
	In order to assemble anything, we have to call it with the parameters described in the previous chapters. There is nothing complicated with it, but if you would like to see an example code take a look at <i><a href="#quick_start-assembler">quick guide</a></i> for the assembler.
</p>
<p>
	The assembler uses the mnemonic from the GIM to get all instruction forms available for it. Then it checks which forms can be used in order to assemble the given instruction model. When instruction forms are validated and accepted, the optimizer chooses the best combination of the address size attribute and operand size attribute for each accepted instruction. In the next step everything is passed to the instruction encoder which consists of a chain of instruction part encoders which in turn are responsible for encoding independent instruction parts like prefixes, ModR/M, operands etc. Finally, all encoded parts are assembled into the machine code of the instruction as a whole. The encoding process is repeated for every accepted instruction form. Of course the whole process is a bit more complicated but this description should provide a general view at a high level of abstraction.
</p>
<p>
	This function is thread-safe so it can be safely called simultaneously by multiple threads but you have to be sure that at least the context and result are not shared across threads.
</p>

<h3 id="assembler-multi-pass" class="experimental">Multi pass assembler</h3>
<p>
	The FCML library supports simple multi-pass load-and-go assembling, which has been designed to be able to assemble multiple lines of source code at once. This is an experimental implementation and it has not been well tested yet, so I would be grateful for any feedback. There are few unit tests there. I also used it for my own purpose, but I definitely haven't spent as much time as I should testing and using it to call it a stable and mature implementation.
</p>
<p>
	As well as the classic one-line assembler it needs an initialized dialect instance to work. It is just a wrapper to the one-line assembler, so you have to initialize an assembler instance as well. Let's see a declaration of the function that assembles the source code:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_lag_assemble( 
	fcml_st_lag_assembler_context *context, 
	const fcml_string *source_code, 
	fcml_st_lag_assembler_result *result );
</pre>
<p>
	The first thing you have to prepare is an assembler context instance, but in this case it is a dedicated <i><a href="api/structfcml__st__lag__assembler__context.html">fcml_st_lag_assembler_context</a></i> structure. It is almost the same structure as in case of the one-line assembler, so there is no need to describe it in every detail. The only difference is a symbol table which can be used to pass additional custom symbols to the assembler and to return symbols allocated by the assembler itself to the user (As you will see it may be really useful in practice.):
</p>
<pre class="brush: cpp">
typedef struct fcml_st_lag_assembler_context {
    fcml_st_dialect *dialect;
    fcml_st_assembler *assembler;
    fcml_st_assembler_conf configuration;
    fcml_st_entry_point entry_point;
    fcml_st_symbol_table symbol_table;
} fcml_st_lag_assembler_context;
</pre>
<p>
	The symbol table is described in the dedicated chapter: <a href="#symbols">Symbols</a>.
</p>
<p>
	The next parameter is <i>source_code</i> which points to an array of strings, where every string represents one instruction to assemble. 
</p>
<p>
	In case of the multi-pass assembler it would be quite inconvenient to work with general instruction models, so in this case we need to provide source code using the syntax which is supported by the chosen dialect. It is more natural and supports features like symbols, labels and mathematical operators.
</p>
<p>
	The assembled code is returned in a dedicated structure too:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_lag_assembler_result {
	fcml_st_ceh_error_container errors;
	fcml_int error_line;
	fcml_st_assembled_instruction *instructions;
} fcml_st_lag_assembler_result;

</pre>
<p>
	The first field holds errors, then we have the number of the source code line where the assembler failed and a list of instructions if everything succeeded.
</p>
<p>
	Every assembled instruction is represented by the following structure:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_lag_assembled_instruction {
    struct fcml_st_assembled_instruction *next;
    fcml_st_ceh_error_container warnings;
    fcml_uint8_t *code;
    fcml_usize code_length;
} fcml_st_lag_assembled_instruction;
</pre>
<p>
	The used pattern is similar to the one-line assembler, but in this case every position in the instructions chain represents one line of the assembled source code. There are no duplicates like in case of the one-line assembler. It is just impossible because addresses used by assembled code have to be consistent and as so they are strictly connected with the size of the code between the branch instruction and the related label. So in order to generate a block of code which for example could be then executed, you have to iterate through the whole chain and copy every instruction code to the destination code segment.
</p>
<p>
	The result structure has to be prepared in the same way as for the one-line assembler (For more details see: <a href="#asm-result">Preparing assembler result</a>). It uses exactly the same model, the only difference is functions used to prepare and free the result structure. In this case you have to use the function <i><a href="api/fcml__lag__assembler_8h.html#a58bb7fe6737e3bd201321c42cfff32f8">fcml_fn_lag_assembler_result_prepare</a></i> to prepare the result and <i><a href="api/fcml__lag__assembler_8h.html#af9ddd516549fa96a840694fae30144d0">fcml_fn_lag_assembler_result_free</a></i> to free it if it is no longer needed.
</p>
<p>
	Let's take a look at the following piece of code:
</p>
<pre class="brush: cpp">
fcml_string source_code[] = {
	"start:      mov ebx, 1",
	"loop_big:   inc ebx",
	"            cmp ebx, 10",
	"            je  finish",
	"loop_small: mov eax, 1",
	"increment:  inc eax",
	"            cmp eax, 10",
	"            je  finish_small",
	"            jmp increment",
	"finish_small:",
	"            jmp loop_big",
	"finish:     ret",
	NULL
};

fcml_uint8_t assembled_instructions[] = {
	0xBB, 0x01, 0x00, 0x00, 0x00,
	0x43,
	0x83, 0xFB, 0x0A,
	0x74, 0x0F,
	0xB8, 0x01, 0x00, 0x00, 0x00,
	0x40,
	0x83, 0xF8, 0x0A,
	0x74, 0x02,
	0xEB, 0xF8,
	0xEB, 0xEB,
	0xC3
};
</pre>
<p>
	The first array contains the source code being assembled and the second one contains the machine code of the assembled instructions.
</p>
<p>
	Look at the forth assembled instruction: "<tt>je  finish</tt>", as you can see it was assembled to the following piece of code: <tt>0x740F</tt>. In this case the assembler made a choice and decided that this jump can be encoded through the use of 8-bit displacement relative to the instruction pointer.  The current implementation is a classic multi-pass assembler which assembles code in the multiple passes in order to generate the best code possible. 
</p>
<p>
	This implementation is based on the standard parsers used as well in case of the one-line assembler so everything they support is obviously available here. 
</p>
<p>
	As it was mentioned above, there is a symbol table in the assembler context. The symbol table is bidirectional and can be used to pass additional symbols (which are not defined in the code) to the assembler as well as to access symbols defined in the assembled code.
</p>
<p>
	It can be a very useful feature, because after code is compiled you can easily check the address of every label defined in the source code. For instance, if you have assembled the source code available above, you can then check the address of the "<tt>finish</tt>" label using <i><a href="api/fcml__symbols_8h.html#a6cc6a122923703f305981c4aa605b08e">fcml_fn_symbol_get</a></i> function (See: <a href="#symbols">Symbols</a> for more information about how symbols can be accessed.). 
</p>
<p>
	Like almost every FCML function, the multi pass load-and-go assembler is thread-safe and can be used across multiple threads using separated assembler contexts and results.
</p>
<p>
	Although this assembler can be really useful, as opposed to the one-line assembler, it is still an experimental implementation so I cannot wait to have feedback from you. If you are interested in the way it was implemented do not hesitate to check the <i>fcml_lag_assembler.c</i> source file. The source code is well commented, so it should not be a big problem to understand the whole idea behind it. Unit tests are available in "check/internal-tests/lag_assembler_t.c".
</p>
<p>
	The following example assembles a few lines of source code and prints the symbols and the machine code to the output:
</p>
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;fcml/fcml_lag_assembler.h&gt;
#include &lt;fcml/fcml_intel_dialect.h&gt;
#include &lt;fcml/fcml_symbols.h&gt;

fcml_string source_code[] = {
	"_start: push ebp",
	"    mov  ebp,esp",
	"    mov  eax,dword ss:[ebp+8]",
	"    cmp  eax, 1",
	"    je   _ignore_call",
	"    call sys_function",
	"_ignore_call:",
	"    mov  esp,ebp",
	"    pop  ebp",
	"    ret",
	NULL
};

void print_symbol( fcml_st_symbol_table symbol_table, fcml_string symbol_name ) {
	fcml_st_symbol *symbol = fcml_fn_symbol_get( symbol_table, symbol_name );
	if( symbol ) {
		printf("  %s: 0x%lx\n", symbol_name, (fcml_uint64_t)symbol->value );
	} else {
		printf("  %s: Not found\n", symbol_name );
	}
}

int main(int argc, char **argv) {

	fcml_ceh_error error;

	fcml_st_dialect *dialect;

	error = fcml_fn_dialect_init_intel( FCML_INTEL_DIALECT_CF_DEFAULT, &amp;dialect );
	if( error ) {
		fprintf( stderr, "Can not initialize the Intel dialect: %d", error );
		exit(1);
	}

	fcml_st_assembler *assembler;

	error = fcml_fn_assembler_init( dialect, &amp;assembler );
	if( error ) {
		fprintf( stderr, "Can not initialize the assembler: %d", error );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	fcml_st_symbol_table symbol_table = fcml_fn_symbol_table_alloc();
	if( !symbol_table ) {
		fprintf( stderr, "Can not allocate the symbol table: %d", error );
		fcml_fn_assembler_free( assembler );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	error = fcml_fn_symbol_add_raw( symbol_table, "sys_function", 0x00405000 );
	if( error ) {
		fprintf( stderr, "Can not add a symbol to the symbol table: %d", error );
		fcml_fn_symbol_table_free( symbol_table );
		fcml_fn_assembler_free( assembler );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	fcml_st_lag_assembler_result result;
	fcml_fn_lag_assembler_result_prepare( &amp;result );

	fcml_st_lag_assembler_context context = {0};
	context.assembler = assembler;
	context.configuration.enable_error_messages = FCML_TRUE;
	context.entry_point.op_mode = FCML_OM_32_BIT;
	context.entry_point.ip = 0x00401000;
	context.symbol_table = symbol_table;

	error = fcml_fn_lag_assemble( &amp;context, source_code, &amp;result );
	if( !error ) {

		printf("Assembled code:\n");

		fcml_st_assembled_instruction *instruction = result.instructions;
		while( instruction ) {
			int i;
			printf("  ");
			for( i = 0; i &lt; instruction-&gt;code_length; i++ ) {
				printf("%02x", instruction->code[i]);
			}
			printf("\n");
			instruction = instruction->next;
		}

		printf("Symbols:\n");

		print_symbol( symbol_table, "_start" );
		print_symbol( symbol_table, "_ignore_call" );
		print_symbol( symbol_table, "sys_function" );

		printf("\n");

	} else {
		fprintf( stderr, "Cannot assemble the source code: %d, line: %d, Message: %s\n", error, result.error_line, result.errors.errors ? result.errors.errors->message : "None." );
		fcml_fn_symbol_table_free( symbol_table );
		fcml_fn_assembler_free( assembler );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	fcml_fn_symbol_table_free( symbol_table );

	fcml_fn_assembler_free( assembler );

	fcml_fn_dialect_free( dialect );

	return 0;

}
</pre>
<p>
	The expected output:
</p>
<pre>
Assembled code:
  55
  8bec
  8b4508
  83f801
  7405
  e8f03f0000
  8be5
  5d
  c3
Symbols:
  _start: 0x401000
  _ignore_call: 0x401010
  sys_function: 0x405000
</pre>

<h2 id="parser">Parser</h2>
<p>
	The following chapters describe all important details of the paring process.
</p>

<h3 id="parser-init-invoke">Initialization and parsing</h3>
<p>
	The possibility of assembling the general instruction model is without a doubt a very useful feature, especially in more advanced techniques, where we need the full control over dynamically generated instructions or when we modify disassembled instructions on the way and assemble them back. 
</p>
<p>
	But what if we work with textual forms of instructions, how to convert them to general instruction models?
</p>
<p>
	An instruction parser is the answer. It is the FCML component responsible for converting one textual instruction into its GIM representation. 
</p>
<p>
	Parsers as well as other FCML components supports different types of dialects, so we can parse the Intel and AT&amp;T syntax.
</p>
<p>
	First of all let's take a look at the function declaration:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_parse( 
	fcml_st_parser_context *context, 
	fcml_string instruction, 
	fcml_st_parser_result *result );
</pre>
<p>
	It should look very familiar because it follows the same convention as the assembler and disassembler. It takes three parameters. The first one is a parser context, then an instruction we would like to parse and a structure which takes the result. So as usual let's start with the context at first:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_parser_context {
	fcml_st_dialect *dialect;
	fcml_st_parser_config config;
	fcml_ip ip;
	fcml_st_symbol_table symbol_table;
} fcml_st_parser_context;
</pre>
<p>
	The first field is of course a dialect instance used to support the syntax we would like to parse. It should be the same dialect instance as the one used by the assembler then (Remember that GIM is syntax-dependent). The next field is a configuration that also is not a surprise when we are familiar with the other FCML components. 
</p>
<p>
	So let's take a look at it:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_parser_config {
	fcml_bool ignore_undefined_symbols;
	fcml_bool disable_symbols_declaration;
	fcml_bool override_labels;
	fcml_bool alloc_symbol_table_if_needed;
	fcml_bool enable_error_messages;
} fcml_st_parser_config;
</pre>
<p>
	In this case, the configuration is not very sophisticated. The first field can be set to <i>FCML_TRUE</i> in order to force the parser to ignore all undefined symbols; or to <i>FCML_FALSE</i> if the parser should fail when such a symbol is found. If undefined symbols are allowed, they are converted to 0. This functionality can be useful if we would like for example to implement a multi-pass assembler (To be honest it was designed and is currently used by the multi pass load-and-go assembler available in the FCML library). 
</p>
<p>
	The second field <i><a href="api/structfcml__st__parser__config.html#a962a987e1d5b01570e05f79bd9c54476">disable_symbols_declaration</a></i> can be used in order to disable support for labels. If it is set to <i>FCML_TRUE</i> every label declaration will cause an error to occur (<i>FCML_CEH_GEC_UNSUPPORTED_LABEL_DECLARATION</i>). It can be very useful when you do not need symbols at all and would not like to care about the symbol table in the context which can be allocated by the parser and has to be manually freed in such a case.
</p>
<p>
	The third field <i><a href="api/structfcml__st__parser__config.html#a1fd92ff9553b495cd3634dcb9a8a7a3a">override_labels</a></i> should be set to <i>FCML_TRUE</i> if we allow overriding existing symbols by labels defined in the code if they share the same symbol name. For example let's imagine that there is a global utility function with a strange name "printf". After passing it to the multi pass assembler we could easily make a call to this utility function using branch instructions, for example: "<tt>call printf</tt>". What if we would like to override it and define our own implementation of the function? It would be possible as long as <i>override_labels</i> was set to <i>FCML_TRUE</i>, because the first existence of the local "printf" label would override the one defined by default. Of course it is only a theory and in practice it is disabled in the FCML multi-pass assembler :)
</p>
<p>
	The forth field <i><a href="api/structfcml__st__parser__config.html#a3b0a862b13bc090e00ce57cb213e9753">alloc_symbol_table_if_needed</a></i> is a bit dangerous and you should understand it well before potential usage. By default the instruction parser ignores all symbol declarations if there is no symbol table provided in the parser context. By setting this value to true you can force the parser to allocate a new symbol table when needed. Remember that you are then responsible for freeing it, so this functionality can be a bit tricky, because you have to check for the existence of the symbol table every time it should be deallocated.
</p>
<p>
	The last field <i><a href="api/structfcml__st__parser__config.html#a69b04861532bbe71e5d55a75a1ff3a92">enable_error_messages</a></i> enables textual error messages for the parser.
</p>
<p>
	Let's back to the parser context. The third field <i><a href="api/structfcml__st__parser__context.html#ac51d65046530cfa26dfa50b2e60c8d11">ip</a></i> holds an instruction pointer (Address where instruction is located in the code segment.). It is used as a value for symbols that are defined for label declarations. So if your IP is <tt>0x401000</tt> and there is the following instruction being parsed "<span class="instruction">loop: add eax, 1</span>", the new symbol loop will be defined with the value set to <tt>0x401000</tt>.
</p>
<p>
	The last but not least field is the symbol table itself. It is a very important structure because using it we are able to exchange symbols with the parser. 
</p>
<p>
	Let's imagine the following example:
</p>
<p>
	You are the author of the best memory monitor in the world. Of course, as an advanced programmer you remember how hard it was to find symbols exported by modules loaded inside a monitored executable using all these simple and unsophisticated competitive products ;). Armed with this experience you decided to load all symbols exported by loaded modules and then provided them as symbols into your one-line assembler. Since that, all your users are able to call system functions as if they were defined directly in their code. For instance, by typing the following code: "<span class="instruction">call CreateWindow</span>" (CreateWindow – A Windows API function using to create a new window.). Of course you can also define some standard constants like MAX_PATH and use them in mathematical computations "<span class="instruction">mov eax, MAX_PATH+1</span>". I do not need to say how useful it can be. 
</p>
<p>
	If you do not need symbols to be used, just leave symbol table empty (I mean <i>NULL</i>) and set the configuration field <i><a href="api/structfcml__st__parser__config.html#a962a987e1d5b01570e05f79bd9c54476">disable_symbols_declaration</a></i> to <i>FCML_TRUE</i>.
</p>
<p>
	Let's back to the function parameters. 
</p>
<p>
	The second parameter is an instruction which points to the textual representation of the assembled instruction. There is nothing to explain here. It is just a plain ASCII string. All one-byte encodings as well as UTF-8 are supported, but you cannot use UNICODE here (Currently the library cannot be compiled with UNICODE support under the Windows, so you need to convert your UNICODE strings to the UTF-8 on your own).
</p>
<p>
	The last parameter <i>result</i> is a container for the function result. Surely it has to be carefully prepared before usage. It follows the same pattern as the other FCML components so first of all let's take a look at the following chapter if you are not familiar with the pattern yet: <a href="#asm-result">Preparing assembler result</a>. In this case the following functions have to be used in order to prepare and free the result container: <i><a href="api/fcml__parser_8h.html#ad8518293f072c18ac06efedd85e27212">fcml_fn_parser_result_prepare</a></i>, <i><a href="api/fcml__parser_8h.html#a220442c7a5b36deaff64c8548a77a6a6">fcml_fn_parser_result_free</a></i>.
</p>
<p>
	This is the structure itself:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_parser_result {
	fcml_st_ceh_error_container errors;
	fcml_st_symbol *symbol;
	fcml_st_instruction *instruction;
} fcml_st_parser_result;
</pre>
<p>
	The first field <i><a href="api/structfcml__st__parser__result.html#a304a4bc5230a6c12c51ccf4bd377d489">errors</a></i> contains information about the reason of the failure. 
</p>
<p>
	The field <i><a href="api/structfcml__st__parser__result.html#a2d7a7638151aca2ce6207ac0ba1bd8fa">symbol</a></i> contains a symbol defined by a label if there was any. We have to spend a little more time here. You have to pay special attention when working with symbols, because even if you did not provide a symbol table inside the context, if there is a label defined by the parsed instruction, the symbol table will be allocated for the new symbol and returned by the context (Only if <i><a href="api/structfcml__st__parser__config.html#a3b0a862b13bc090e00ce57cb213e9753">alloc_symbol_table_if_needed</a></i> configuration field is set to <i>FCML_TRUE</i>; otherwise symbols are just ignored). In such a case you are responsible for freeing it.  Remember that this is the parser context that is responsible for freeing the allocated symbols (Not literally of course.), because there is the symbol table that holds them. You should not really on <i><a href="api/fcml__parser_8h.html#a220442c7a5b36deaff64c8548a77a6a6">fcml_fn_parser_result_free</a></i>, because it frees everything but the symbol returned in the symbol field. In other words, in order to free symbol returned by the parser, free the symbol table from the parser context.
</p>
<p>
	Once all parameters are prepared, we can then call the <i><a href="api/fcml__parser_8h.html#a8104949148708ef9c6c62c7f40ae9991">fcml_fn_parse</a></i> function as follows:
</p>
<pre class="brush: cpp">
error = fcml_fn_parse( &amp;parser_context, instruction, &amp;parser_result );
if( error ) {
	...
}
</pre>
<p>
	As you see, the pattern is exactly the same as in case of others main FCML functions.
</p>
<p>
	At this point we have to stop for a moment and take a look at the subject of the structures ownership. Take into consideration the fact that the structure <i><a href="api/structfcml__st__instruction.html">fcml_st_instruction</a></i> located in the <i><a href="api/structfcml__st__parser__result.html">fcml_st_parser_result</a></i> structure is allocated by the parser. It is very important to be aware that it is the parser that is responsible for freeing it. It can be a bit problematic in cases where you have to parse something but an interpretation is deferred in time, because you cannot free the whole assembler result that occupies unnecessary memory. 
</p>
<p>
	Fortunately, there is a solution to this problem. It is the function called <i><a href="api/fcml__common__utils_8h.html#a6c8c1c647699c48e025c357503650d2d">fcml_fn_cu_clone_instruction</a></i> available in the header file <i><a href="api/fcml__common__utils_8h.html">fcml_common_utils.h</a></i>. This function can be used in order to clone the instruction model prepared by the parser. After the instruction is cloned you are able to free the whole result without any negative consequences. Of course you are responsible for the cloned instance and have to free it using the next <i><a href="api/fcml__common__utils_8h.html#affed0d6abd7004e87a616f6815fa1719">fcml_fn_cu_free_instruction</a></i> function as soon as it is no longer needed. 
</p>
<div class="notice-box">
	Never try to free any FCML structures manually using the plain "free" function, because such structures may be the roots of bigger trees with nested structures that have to be also properly freed. There is one more argument for not freeing it on your own (Because in certain circumstances it is possible anyway.). FCML is a quite flexible library and it even lets the user to replace functions used for memory allocation and deallocation to their own implementations. Now try to imagine the consequences when you use the standard ”free” function in order to deallocate a piece of memory which was allocated by a completely different dedicated memory heap. Statically linked libraries can also use different heaps than the executable that uses them, just by default.
</div>

<h3 id="parser-how-it-works">How parser works</h3>
<p>
	Even if there is only one function used to parse instructions which uses dialects in order to distinguish between supported syntaxes, every dialect has its own dedicated implementation of the parser. It is a very natural solution because parsers tend to be very complicated and they are very difficult if not even impossible to be implemented in a generic way. The main problem here is the grammar itself. It can be compared to the problem with natural languages where grammars differ on such many levels that it is just impossible to implement one generic tool which would be able to parse sentences in all languages using the same algorithm and sets of rules. Every generic solution would need to impose a general set of restrictions for future dialects it would be able to support. I am pretty sure you will agree with me that it is not the best idea to restrict innovation in any way ;)
</p>
<p>
	So FCML currently supports the Intel and AT&amp;T syntax. Every syntax is supported by the one dedicated parser. Every parser implements different set of rules in order to support the given syntax, but anyway they share a piece of common utility code. A good example are functions used to build and interpret an instance of the abstract syntax tree built while an instruction is parsed. It is why some rules are still common for all available parsers.
</p>
<p>
	FCML parsers are built using GNU Bison parser generator and Flex scanner (You do not need them installed to compile the project, as long as you do not change the grammar files).
</p>

<h3 id="parser-common-rules">Common rules</h3>
<p>
	The following chapter covers areas where parsers share the same set of rules which can be described in one place.
</p>

<h4 id="parser-common-numeric">Representation of numeric values</h4>
<p>
	Numeric values can be represented in many different ways on the level of the certain syntax, but they have something in common. After they are properly parsed, they are represented identically in the abstract syntax tree. They are also computed by using exactly the same set of rules, not matter which parser was used to parse the source expression (See: <a href="#parser-common-expressionsExpressions">Expressions handling</a>).
</p>
<p>
	Every integer value is always parsed to the 64-bit unsigned value, because we never know the way the assembler will use the final result. It can use it as an 8-bit immediate value, but it may use it as an 64-bit immediate value for MOV instruction as well. Remember that every parser works with generic instruction models without any knowledge about the context where the models will be used further (They are so called context-less parsers). 
</p>
<p>
	Even if an integer value is written with the sign, for instance -10, it is still parsed to the positive value and then converted to -10 using the unary minus operator. It has to be taken into account especially in case of integer literals written as hexadecimal values. For instance let's take a look at the following example:
</p>
<pre>
50 - 5
</pre>
<p>
	This example is very easy and there is nothing special to be done in the background. The integer literals 50 as well as 5 are parsed to 64-bit unsigned integer values. At this moment they are still treated as unsigned integers. Then they take a part in the expression where the second value (5) is subtracted from the first one (50). Every integer value, which is a part of a mathematical expression, is firstly converted to a signed value. Then computation is made by using the two signed values, so the result is always the signed value as well. 
</p>
<p>
	The rule is simple. As long as a value does not take a part in an expression, it is an unsigned value. Every result of an expression is always a signed value. Notice that the rule is still valid for unary minus operator, because it is also an expression.
</p>
<p>
	The problems start when you work with hexadecimal literals:
</p>
<pre>
10 + 0xFF
</pre>
<p>
	Notice that the final result of this computation strictly depends on the size of the values that take part in the expression. If they were 8-bit values the result would be 9 because the second value would be treated as -1; otherwise if the values were for instance 16 bits in length, the result would be 265. So how such an expression will be evaluated in case of FCML parsers?
</p>
<p>
	The first rule tells us that every integer literal is parsed to an unsigned 64-bit value at first. So the first value is parsed to <tt>0x000000000000000A</tt> and the second one is parsed to <tt>0x00000000000000FF</tt>. Take into consideration that they are still unsigned, because the expression is evaluated later. So we have something like this:
</p>
<pre>
((signed)((unsigned)0x000000000000000A)) + ((signed)((unsigned)0x00000000000000FF))
</pre>
<p>
	The values themselves are unsigned but when the expression is about to be evaluated, they are cast to signed integers and then the computation takes place. So the result of the computation is (signed) <tt>0x0000000000000109</tt>.
</p>
<p>
	You may be under the impression that it is really not important if the result is signed or not here, because the representation of the value is still the same internally, but there is one important difference. From time to time a value has to be extended (Yes extended, everything is explained two paragraphs below) to match the expected size of an immediate operand for example. If the value is unsigned, then it is extended just by padding the value with zeros, so for instance an unsigned <tt>0xFF</tt> 8-bit integer is extended to the <tt>0x00FF</tt> when the 16-bit value is expected. But in case of a signed 8 bits <tt>0xFF</tt> value (i.e. -1) the higher bits are filled with 1's, so the result would be <tt>0xFFFF</tt>. As you can see in certain circumstances you may get two completely different results.
</p>
<p>
	Hence all you need to do is to remember the main general rule: Every integer value is parsed to a 64-bit unsigned value first, and then it can be eventually converted to the signed 64-bit value when it is a part of an expression.
</p>
<p>
	Every parsed integer has 64 bits, right? So is it always returned as the 64-bit integer value in the generic instruction model? The answer is no...
</p>
<p>
	Before a value is placed inside a GIM, the parser tries to convert it to the smallest value possible. So if the result of an expression is signed 64-bit value: -15 it will be converted to the 8-bit signed immediate value for the use of the GIM. Take into account that even if the assembler still expects a 64-bit value, it can be then extended with the sign to match the expected size.  For instance:
</p>
<p>
	The value -15 of the following instruction: "<span class="instruction">add eax, -15</span>" is parsed to the following immediate operand ( FCML_EOT_IMMEDIATE):
</p>
<pre class="brush: cpp">
fcml_st_operand operand = {0};
...
operand.immediate.size = FCML_DS_8;
operand.immediate.is_signed = FCML_TRUE;
operand.immediate.int8 = 0xF1;
...
</pre>
<p>
	Then the assembler interprets this operand as a 32-bit immediate value, so it has to extend the value from the GIM to the expected size. The operand is the signed value so it will be extended to 32 bits: <tt>0xFFFFFFF1</tt>.
</p>
<p>
	If you want to be on the safe side, just remember the second rule: If you use a negative integer typed as a hex literal in an expressions, always use unary minus operator. So instead of writing <tt>0xFFFFFFF1</tt> use <tt>-0x0000000F</tt> or <tt>-0xF</tt>.
</p>
<p>
	All this theory might be a bit complicated, so take a look at the following examples:
</p>
<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<caption>Example expressions</caption>
		<thead>
			<tr>
				<th>Expression</th>
				<th>Explanation</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td><tt>0xFFFFFFFF + 0xFFFFFFFF</tt></td>
				<td>
					<p>
						The literals are converted to two 64-bit unsigned <tt>0x00000000FFFFFFFF</tt> values and then are added to each other resulting with the 64-bit signed <tt>0x00000001FFFFFFFE</tt> value. The result is then returned as a 64-bit immediate value in the GIM, because only the 64-bit value is able to represent such a big numbers.
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>0xFFFFFFFF</tt></td>
				<td>
					<p>
						Let us suppose that in this case an instruction needs a 32-bit signed integer value as an operand. The parser knows nothing about the context so it will parse it to a 64-bit unsigned integer. The value does not take a part in any expression so it remains unsigned. Then it is converted to the smallest possible unsigned immediate integer. The smallest unsigned integer variable that would be able to take this value has to be 32 bits long. So inside the GIM it will be represented as an unsigned 32-bit integer variable set to <tt>0xFFFFFFFF</tt>. Now let's get back to the instruction. It needs the 32-bit signed integer as the operand value. Notice that size matches in this case (It is really important fact!), so value has not to be extended in any way. In such a case a simple cast is made, so in the result the operand will be also set to a 32-bit integer value <tt>0xFFFFFFFF</tt>, but in this case it will be further interpreted as -1. Anyway take into account that it would not work if you typed <tt>0xFFFF</tt>, because it would be intimately converted to <tt>0x0000FFFF</tt>.
					</p>
					<p>
						There is only one rule you need to follow when you use hexadecimal literals which are not used in expressions: If the value has to be interpreted as a negative one, write it using exactly as much characters as needed in a given context. 
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>100 - -0x0F</tt></td>
				<td>
					<p>
						100 is parsed to 64-bit <tt>0x0000000000000064</tt>.Then <tt>0x0F</tt> is parsed to an unsigned <tt>0x000000000000000F</tt>. The unary operator has higher precedence than "-" (minus), so firstly the second operand is changed to a signed <tt>0xFFFFFFFFFFFFFFF1</tt>. Then the first operand is changed to a signed value and the second operand is subtracted from it. So writing the expression using decimals we have 100 + 15. Hence the result is <tt>0x0000000000000073</tt>. The immediate operand returned inside the GIM will be a 8-bit signed <tt>0x71</tt> value.
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</div>

<h4 id="parser-common-expressions">Expressions handling</h4>
<p>
	An expression is a combination of symbols like numeric values, constants etc. formatted according to some general rules and grouped by using operators and brackets. For instance this is an example of an expression which can be appropriately parsed by the Intel parser as well as by AT&amp;T:
</p>
<pre>
( ( start – end ) * 2 ) + 1
</pre>
<p>
	It follows general mathematical expressions rules supported as well by almost every programming language, so I do not think it is a place and time to describe such basics.
</p>
<p>
	The one important thing here is a list of the operators currently supported by parsers (They are ordered by precedence):
</p>
<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<caption>Example expressions</caption>
		<thead>
			<tr>
				<th>Operator</th>
				<th>Name</th>
				<th>Description</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td><tt>+</tt></td>
				<td><p>Addition</p></td>
				<td><p>Adds two operands to each other.</p></td>
			</tr>
			<tr>
				<td><tt>-</tt></td>
				<td><p>Subtraction</p></td>
				<td><p>Subtracts two operands from each other.</p></td>
			</tr>
			<tr>
				<td><tt>*</tt></td>
				<td><p>Multiplication</p></td>
				<td><p>Multiplies one operand by another.</p></td>
			</tr>
			<tr>
				<td><tt>/</tt></td>
				<td><p>Division</p></td>
				<td><p>Divides the first operand by the second one.</p></td>
			</tr>
			<tr>
				<td><tt>-</tt></td>
				<td><p>Unary minus</p></td>
				<td><p>Additive inverse.</p></td>
			</tr>
		</tbody>
	</table>
</div>

<h3 id="parser-intel">Intel parser</h3>
<p>
	Parsers which follows the Intel syntax are based on the syntax proposed by the Intel manuals to the x86_64 architecture. The following chapters describe some specific aspects of the Intel syntax (From the point of view of the FCML Intel dialect). If you are interested how the Intel parser works do not hesitate to take a look at the following source files:
</p>
<p>
Rules for Flex scanner generator: ${dist}/src/fcml_intel_lexer.l<br>
BNF grammar for Bison parser generator: ${dist}/src/fcml_intel_parser_def.y
</p>
<p>
	Remember that it is out of the scope of this manual to describe every aspect of the Intel syntax in general. My objective is just to describe everything that is often implemented in different ways across various assembler/disassembler implementations.
</p>

<h4 id="parser-intel-numeric">Numeric values</h4>
<p>
	Decimal literals are written in the standard mathematical way using digits from 0-9 (Regular expression: [0-9]+d?). For example: 12, 1 or 112. You can add “d” suffix but it is optional. So they are the same values: 12, 12d. There is nothing special about it so let us take a look at hexadecimal values. 
</p>
<p>
	There are two ways hexadecimal literals may be written. The first one uses a convention popularized by C-like programming languages with the prefix <tt>0x</tt>, for example <tt>0xFF</tt> or <tt>0x12</tt>. The second convention is used mostly by Intel assemblers and uses "h" suffix. For instance <tt>12Fh</tt>, <tt>0FFh</tt>. As you might have noticed, there are values that might start with the letter, for example <tt>FF</tt>. In order to distinguish them from named symbols use the precedent 0, for example <tt>0FFh</tt>.
</p>
<p>
	Float values are currently not supported, because they are not used directly in instructions and pseudo operations other than "db" used for data allocation are not supported by FCML yet.
</p>

<h4 id="parser-intel-registers-expressions">Registers</h4>
<p>
	The following table shows register symbols used by the Intel parser:
</p>
<table class="table table-bordered fcml-table">
	<caption>Registers supported by the Intel parser</caption>
	<thead>
		<tr>
			<th>Type</th>
			<th>Registers</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td>8-bit general purpose registers</td>
			<td><p>al, cl, dl, bl, ah, ch, dh, bh, r8l, r9l, r10l, r11l, r12l, r13l, r14l, r15l, spl, bpl, sil, dil.</p></td>
		</tr>
		<tr>
			<td>16-bit general purpose registers</td>
			<td><p>ax, cx, dx, bx, sp, bp, si, di, r8w, r9w, r10w, r11w, r12w, r13w, r14w, r15w</p></td>
		</tr>
		<tr>
			<td>32-bit general purpose registers</td>
			<td><p>eax, ecx, edx, ebx, esp, ebp, esi, edi, r8d, r9d, r10d, r11d, r12d, r13d, r14d, r15d</p></td>
		</tr>
		<tr>
			<td>64-bit general purpose registers</td>
			<td><p>rax, rcx, rdx, rbx, rsp, rbp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15</p></td>
		</tr>
		<tr>
			<td>SIMD(64) – MMX</td>
			<td><p>mm0, mm1, mm2, mm3, mm4, mm5, mm6, mm7</p></td>
		</tr>
		<tr>
			<td>SIMD(128) – XMM</td>
			<td><p>xmm0, xmm1, xmm2, xmm3, xmm4, xmm5, xmm6, xmm7, xmm8, xmm9, xmm10, xmm11, xmm12, xmm13, xmm14, xmm15</p></td>
		</tr>
		<tr>
			<td>SIMD(256) – YMM</td>
			<td><p>ymm0, ymm1, ymm2, ymm3, ymm4, ymm5, ymm6, ymm7, ymm8, ymm9, ymm10, ymm11, ymm12, ymm13, ymm14, ymm15</p></td>
		</tr>
		<tr>
			<td>FPU</td>
			<td>
				<p>
					st(0), st(1), st(2), st(3), st(4), st(5), st(6), st(7)<br>
					OR<br>
					st0, st1, st2, st3, st4, st5, st6, st7
				</p>
			</td>
		</tr>
		<tr>
			<td>Control registers</td>
			<td><p>cr0, cr2, cr3, cr4, cr8</p></td>
		</tr>
		<tr>
			<td>Debug registers</td>
			<td><p>dr0, dr1, dr2, dr3, dr4, dr5, dr6, dr7</p></td>
		</tr>
		<tr>
			<td>Instruction pointer register</td>
			<td><p>RIP (Used only with RIP addressing.)</p></td>
		</tr>
	</tbody>
</table>

<h4 id="parser-intel-size-operators">Size operators</h4>
<p>
	Here is a list of size operators used to specify the size of memory data accessed by an instruction. If there are any alternatives they are separated by commas:
</p>
<table class="table table-bordered fcml-table">
	<caption>Size operators supported by the Intel parser</caption>
	<thead>
		<tr>
			<th>Operators</th>
			<th>Data size</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><tt>byte, byte ptr</tt></td>
			<td>8 bits</td>
		</tr>
		<tr>
			<td><tt>word, word ptr</tt></td>
			<td>16 bits</td>
		</tr>
		<tr>
			<td><tt>dword, dword ptr</tt></td>
			<td>32 bits</td>
		</tr>
		<tr>
			<td><tt>fword ptr, pword ptr, fword, pword</tt></td>
			<td>48 bits</td>
		</tr>
		<tr>
			<td><tt>qword, qword ptr</tt></td>
			<td>64 bits</td>
		</tr>
		<tr>
			<td><tt>tbyte, tword, tbyte ptr, tword ptr</tt></td>
			<td>80 bits</td>
		</tr>
		<tr>
			<td><tt>dqword, oword, dqword ptr, oword ptr</tt></td>
			<td>128 bits</td>
		</tr>
		<tr>
			<td><tt>qqword, qqword ptr</tt></td>
			<td>256 bits</td>
		</tr>
		<tr>
			<td><tt>mmword, mmword ptr</tt></td>
			<td>Multimedia 64 bits</td>
		</tr>
		<tr>
			<td><tt>xword, xmmword, xword ptr, xmmword ptr</tt></td>
			<td>Multimedia 128 bits</td>
		</tr>
		<tr>
			<td><tt>yword, ymmword, yword ptr, ymmword ptr</tt></td>
			<td>Multimedia 256 bits</td>
		</tr>
		<tr>
			<td><tt>14byte, 14byte ptr</tt></td>
			<td>14 bytes</td>
		</tr>
		<tr>
			<td><tt>28byte, 28byte ptr</tt></td>
			<td>28 bytes</td>
		</tr>
		<tr>
			<td><tt>94byte, 94byte ptr</tt></td>
			<td>94 bytes</td>
		</tr>
		<tr>
			<td><tt>108byte, 108byte ptr</tt></td>
			<td>108 bytes</td>
		</tr>
	</tbody>
</table>
<p>
	All multimedia size operators additionally set <i>FCML_OP_HINT_MULTIMEDIA_INSTRUCTION</i> hint for the memory addressing operand. It is useful in one specific case:
</p>
<p>
	In general, the multimedia size operators can be used interchangeably with the standard ones, because they share the same sizes. So they are used mainly as discriminators  in order to hint the assembler that we are using SIMD instructions. For instance "mmword ptr" can be changed to the "qword ptr" and everything will be working like a harm, but there is one case when it do really matter which one we have chosen. 
</p>
<p>
	There are instructions that are ambiguous, for example:
</p>
<table class="table table-bordered fcml-table">
	<tbody>
		<tr>
			<td><tt>0F 6F /r</tt></td>
			<td><tt>MOVQ mm, mm/m64</tt></td>
			<td><tt>MMX move quarword from mm/m64 to mm.</tt></td>
		</tr>
		<tr>
			<td><tt>REX.W 0F 6E /r</tt></td>
			<td><tt>MOVQ mm, r/m64</tt></td>
			<td><tt>MMX move quadword from r/m64 to mm.</tt></td>
		</tr>
	</tbody>
</table>
<p>
	In general they do exactly the same thing, but if you look closely you will see that they differ in the way they access registers when two register operands are used. The first one expects a MMX register while the second one expects a 64-bit general purpose register. Therefore in case of two registers everything is okay and there is no ambiguity here. But what if the second operand accesses the memory?
</p>
<p>
	In such a case we have a little problem here, because both of the instruction above can be used to encode the following instruction: 
</p>
<table class="table table-bordered fcml-table">
	<tbody>
		<tr>
			<td><tt>movq mm0,[rax]</tt></td>
			<td>
				<tt>
					0x0f, 0x6f, 0x00</br>
					0x48, 0x0f, 0x6e, 0x00
				</tt>
			</td>
		</tr>
	</tbody>
</table>
<p>
	If the default instruction chooser is used the first instruction form will always be chosen just because it is the shorter one. But what if we would like to choose one of them explicitly?
</p>
<p>
	The size operators are the answer here. Even if data size operators are interchangeable (multimedia with classic) for instructions which are not ambiguous, using the certain one can help us in such cases:
</p>
<table class="table table-bordered fcml-table">
	<tbody>
		<tr>
			<td><tt>movq mm0, mmword ptr[rax]</tt></td>
			<td><tt>0x0f, 0x6f, 0x00</tt></td>
		</tr>
		<tr>
			<td><tt>movq mm0, qword ptr [rax]</tt></td>
			<td><tt>0x48, 0x0f, 0x6e, 0x00</tt></td>
		</tr>
	</tbody>
</table>
<p>
	By using the specific data size operator you can choose between two instruction encoding forms.
</p>
<p>
	This feature is available only in the case of the Intel dialect. The AT&amp;T dialect does not support it.
</p>

<h4 id="parser-intel-prefixes">Prefixes</h4>
<p>
	The following explicit prefixes are supported by the Intel syntax:
</p>
<table class="table table-bordered fcml-table">
	<caption>Explicit prefixes</caption>
	<thead>
		<tr>
			<th>Prefix</th>
			<th>Value</th>
		</tr>
	</thead>
	<tbody>
		<tr>
			<td><tt>lock</tt></td>
			<td><tt>0xF0</tt></td>
		</tr>
		<tr>
			<td><tt>repne/repnz</tt></td>
			<td><tt>0xF2</tt></td>
		</tr>
		<tr>
			<td><tt>repe/repz/rep</tt></td>
			<td><tt>0xF3</tt></td>
		</tr>
		<tr>
			<td><tt>xacquire</tt></td>
			<td><tt>0xF2</tt></td>
		</tr>
		<tr>
			<td><tt>xrelease</tt></td>
			<td><tt>0xF3</tt></td>
		</tr>
		<tr>
			<td><tt>branch</tt></td>
			<td><tt>0x2E</tt></td>
		</tr>
		<tr>
			<td><tt>nobranch</tt></td>
			<td><tt>0x3E</tt></td>
		</tr>
	</tbody>
</table>
<p>
	If you do not known any of these do not hesitate to look at the Intel or AMD architecture manual.
</p>

<h4 id="parser-intel-hints">Hints</h4>
<p>
	In case of the Intel dialect more than one hint can be used for an instruction. For example this instruction is perfectly valid: "<span class="instruction">jmp indirect near dword ptr [eax]</span>".
</p>
<p>
	The following hints are used by the Intel syntax:
</p>
<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<caption>Hint keywords</caption>
		<thead>
			<tr>
				<th>Hint</th>
				<th>Example</th>
				<th>Description</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td><tt>far</tt></td>
				<td><tt>call far 6655h:44332211h</tt></td>
				<td>
					<p>
						A <b>far</b> jump to the address located in a different code segment than the current one.
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>near</tt></td>
				<td><tt>call near dword ptr [edi+00000001h]</tt></td>
				<td>
					<p>
						A <b>near</b> jump inside the current code segment.
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>long_form</tt></td>
				<td><tt>vmaxsd long_form xmm3,xmm7,xmm0</tt></td>
				<td>
					<p>
						Encodes instruction using three bytes VEX prefix.
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>indirect</tt></td>
				<td><tt>jmp indirect dword ptr [eax]</tt></td>
				<td>
					<p>
						An offset is specified indirectly by an effective address or general purpose register.
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>rel</tt></td>
				<td><tt>rcl byte ptr [rel 0000800000401007h],03h</tt></td>
				<td>
					<p>
						Encodes given address using the RIP addressing. Useful in the 64-bit mode only.
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>abs</tt></td>
				<td><tt>rcl byte ptr [abs 0000000000401007h],03h</tt></td>
				<td>
					<p>
						Encodes given address as an absolute one. Take into account that the address here (<tt>0000000000401007h</tt>) differs from the address from "rel" hint. It is because using absolute addressing you are able to address 4GB of memory only.
					</p>
				</td>
			</tr>
			<tr>
				<td><tt>sib</tt></td>
				<td>
					<tt>
						<p>
							<u>32-bit mode:</u><br>
							rcl byte ptr [sib 00401007h],03h
						</p>
						<p>
							<u>64-bit mode:</u><br>
							rcl byte ptr [sib 00401007h],03h
						</p>
					</tt>
				</td>
				<td>
					<p>
						Forces SIB based encoding to be used. 
					</p>
					<p>
						In the first example SIB is not necessary to encode this instruction, so it encodes to: <tt>0xc0150710400003</tt> (Only the ModR/M field and the displacement.). But when SIB is forced, the same instruction encodes to: <tt>0xc0<b>14</b>250710400003</tt> (ModR/M, SIB and displacement). Remember that not every addressing mode can be encoded with the SIB byte.
					</p>
					<p>
						The second example is an interesting combination. The RIP addressing should be used here by default,  but there is the SIB hint defined. Hints have higher precedence so it implicitly forces absolute addressing to be used (Because absolute offset is encoded using the SIB byte). In this case the SIB hint works like an ABS one. However it does not mean you should use it this way, it is just a side effect of the way x86_64 architecture encodes absolute addresses :)
					</p>
				</td>
			</tr>
		</tbody>
	</table>
</div>

<h3 id="parser-gas">AT&amp;T parser</h3>
<p>
	Parsers which follows the AT&amp;T syntax are based on the syntax which was created at AT&amp;T Bell Labs and is mainly used in UNIX-like environments. The following chapters describe some specific aspects of the AT&amp;T syntax. If you are interested how the AT&amp;T parser works do not hesitate to take a look at the following source files:
</p>
<p>
	Rules for Flex scanner generator: ${dist}/src/fcml_gas_lexer.l<br>
	BNF grammar for Bison parser generator: ${dist}/src/fcml_gas_parser_def.y
</p>
<p>
	You may wonder why GAS term is used to describe the AT&amp;T syntax. The answer is simple. AT&amp;T cannot be used as a valid C symbol. Since the GAS (GNU assembler) is in fact the reference implementation of the syntax now, it is justified to call it GAS syntax as well. The more that the main goal of the dialect is to be compatible with the GNU assembler.
</p>

<h4 id="parser-gas-numeric">Numeric values</h4>
<p>
	Decimal literals are written in the standard way using digits from 0-9 (Regular expression: ([1-9][0-9]*|0+)). For example: 12, 1 or 112. 
</p>
<p>
	Hexadecimal literals use a convention popularized by C-like programming languages with the prefix <tt>0x</tt>, for example <tt>0xFF</tt> or <tt>0x12</tt> (Regular expression: 0x[0-9a-f]+). 
</p>
<p>
	Float values are currently not supported, because they are not used directly with instructions and the pseudo operations other than ".byte" used to data allocation are not supported by FCML yet.
</p>

<h4 id="parser-gas-registers-expressions">Registers</h4>
<p>
	All used registers are the same as in case of the Intel syntax (see: <a href="#parser-intel-registers-expressions">Registers</a>) but they are preceded by "%" character.
</p>

<h4 id="parser-gas-size-operators">Size operators</h4>
<p>
	The AT&amp;T syntax does not use size operators. This information is encoded in the instruction mnemonic as appropriate suffixes. FCML is GAS compatible in this case.
</p>

<h4 id="parser-gas-prefixes">Prefixes</h4>
<p>
	The AT&amp;T dialect supports the same set of prefixes as the Intel syntax (see: <a href="#parser-intel-prefixes">Prefixes</a>).
</p>

<h4 id="parser-gas-hints">Hints</h4>
<p>
	There are only two hints currently supported by the GAS dialect. Some instruction mnemonics like "lcall" adds instruction level hints like: <i>FCML_HINT_FAR_POINTER</i> and <i>FCML_HINT_INDIRECT_POINTER</i>. <i>FCML_HINT_INDIRECT_POINTER</i> hint can be also specified explicitly using '*' (asterisk) indirect operator for example: <span class="instruction">jmpq *(%rax)</span>
</p>

<h2 id="disassembler">Disassembler</h2>
<p>
	The FCML disassembler decodes machine code and converts it to the general instruction model structure. Despite the GIM it also returns some additional detailed information about the instruction in another dedicated structures. The FCML disassembler is able to disassemble one instruction at a time. The main goal here is to make the API as simple as possible, so in order to disassemble a whole block of code you have to invoke the disassembler multiple times. For now, there is no utility function which would make it easier.
</p>
<p>
	The fact that the GIM is used as the result of the disassembling process allows us to analyse disassembled instructions easily. It is almost impossible (or at least very inconvenient) in case of disassemblers that return the textual instructions directly. Such a solution has the following advantages:
</p>
<ul>
	<li>
		<p>
			You are able to analyse instructions easily just by analysing the well known common generic instruction model.
		</p>
	</li>
	<li>
		<p>
			You can assemble instructions back to the machine code using the FCML assembler. For instance you are able to disassemble a branch instruction, then change the offset and assemble it back.
		</p>
	</li>
	<li>
		<p>
			You can avoid the rendering process if it is not needed.
		</p>
	</li>
</ul>

<h3 id="disassembler-init">Initializing disassembler instance</h3>
<p>
	Let us initialize a disassembler instance using <i><a href="api/fcml__disassembler_8h.html#a795996631b091a97e7ae1d04a6015522">fcml_fn_disassembler_init</a></i> function:
</p>
<pre class="brush: cpp">
fcml_st_disassembler *disassembler;
error = fcml_fn_disassembler_init( dialect, &amp;disassembler );
</pre>
<p>
	To make the code clearer, error handling has been avoided in this case, but it should be implemented in the same way as in case of the dialect initialization. All possible error codes are defined in the include file <i><a href="api/fcml__errors_8h.html">fcml_errors.h</a></i> (See: <a href="#error-handling">Error handling</a>)
</p>

<h3 id="disassembler-result">Initializing disassembler result</h3>
<p>
	Having initialized the dialect and disassembler, there is the last thing to be done before disassembling is possible. It is the disassembler result structure. This structure is reusable so it has to be prepared in the right way in order to allow the disassembler to reuse it correctly. To do so, a manually allocated structure has to be passed to the <i><a href="api/fcml__disassembler_8h.html#abdabab5a8ea6cf25a818f11ba3706a58">fcml_fn_disassembler_result_prepare</a></i> function.
</p>
<pre class="brush: cpp">
fcml_st_disassembler_result result;
fcml_fn_disassembler_result_prepare( &amp;result );
</pre>
<p>
	That is all, the disassembler is fully prepared to do its job, so let us try to disassemble a piece of machine code.
</p>

<h3 id="disassembler-disassembling">Disassembling machine code</h3>
<p>
	The first thing to do is to prepare a disassembler context structure. It consists of a disassembler instance which should be used to disassemble code, some configuration flags we can use to configure the disassembling process, entry point which will be used to inform the disassembler about the code segment and a piece of instruction machine code to be disassembled. 
</p>
<p>
	The disassembler context itself can be allocated on the stack, but it is very important to clear the memory it uses before initializing it and passing it to the disassembler. We should do it just to set all configuration options and other parameters to their default values. For example, the following code is the proper way how to initialize the disassembler context:
</p>
<pre class="brush: cpp">
fcml_st_disassembler_context context = {0};
</pre>
<p>
	Let us take a look at the <i><a href="api/structfcml__st__disassembler__context.html">fcml_st_disassembler_context</a></i> structure first:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_disassembler_context {
	fcml_st_disassembler *disassembler;
	fcml_st_disassembler_conf configuration;
	fcml_st_entry_point entry_point;
	fcml_ptr code;
	fcml_data_size code_length;
} fcml_st_disassembler_context;
</pre>
<p>
	The first field <i><a href="api/structfcml__st__disassembler__context.html#af4eb1be295bd4c9d959a99f70c791b0f">disassembler</a></i> should point to a disassembler instance we would like to use. The field <i><a href="api/structfcml__st__disassembler__context.html#afbb61d1762f648f41406d971c8cb0248">entry_point</a></i> describes a code segment used while disassembling code (See: <a href="#un-entry-point">Understanding entry point</a>). Then field <i><a href="api/structfcml__st__disassembler__context.html#a773efa2fa6b9600627b5b85f1570109d">code</a></i> which points to a memory buffer where an instruction machine code is located and the last one <i><a href="api/structfcml__st__disassembler__context.html#aa517a01756088a93f0f5608632c511ac">code_length</a></i> contains the length of the code in the buffer. The last thing there is a configuration structure. It contains a lot of configuration fields, so instead of copying its source code here let describe the fields only:
</p>
<dl class="dl-asm-conf-horizontal-big">
	<dt>increment_ip</dt>
	<dd>
		<p>
			If the flag is set to <i>FCML_TRUE</i> the instruction pointer is incremented and the buffer length is decremented by the size of an assembled instruction every time when the disassembling process succeeded. It can be very useful when we are disassembling multiple instructions one by one.
		</p>
	</dd>
	<dt>enable_error_messages</dt>
	<dd>
		<p>
			If the flag is set to <i>FCML_TRUE</i> textual error messages are generated and returned through <i><a href="api/structfcml__st__disassembler__result.html">fcml_st_disassembler_result</a></i> structure.
		</p>
	</dd>
	<dt>carry_flag_conditional_suffix</dt>
	<dd>
		<p>
			If the flag is set to <i>FCML_TRUE</i> is enables "carry suffixes" for conditional instructions. See the table with instruction suffixes in the <a href="#instruction-renderer">Instruction renderer</a> chapter.
		</p>
	</dd>
	<dt>conditional_group</dt>
	<dd>
		<p>
			This flag can be set to <i>FCML_DASM_CONDITIONAL_GROUP_1</i> or to <i>FCML_DASM_CONDITIONAL_GROUP_2</i> in order to choose a conditional suffixes group. See the table with instruction suffixes in the <a href="#instruction-renderer">Instruction renderer</a> chapter.
		</p>
	</dd>
	<dt>short_forms</dt>
	<dd>
		<p>
			If the flag is set to <i>FCML_TRUE</i> then short instructions forms are used when disassembling code. So for instance "<span class="instruction">cmps byte ptr [si],byte ptr [di]</span>" is disassembled as "<span class="instruction">cmpsb</span>" (Operands are empty).
		</p>
	</dd>
	<dt>extend_disp_to_asa</dt>
	<dd>
		<p>
			If the flag is set to <i>FCML_TRUE</i>, the size of the displacement will always be the same as the effective address size attribute of the disassembled instruction.
		</p>
	</dd>
</dl>
<p>
	So at first let us prepare a configuration structure using the flags described above:
</p>
<pre class="brush: cpp">
context.configuration.enable_error_messages = FCML_TRUE;
context.configuration.short_forms = FCML_TRUE;
</pre>
<p>
	The disassembler is configured but we still have not provided instruction machine code yet. It can be done by setting the following two additional context fields: <i>code</i> and <i>code_length</i>.
</p>
<pre class="brush: cpp">
context.code = code;
context.code_length = sizeof( code );
</pre>
<p>
	The field <i>code</i> should be a pointer to an array of bytes which contains the instruction machine code and field <i>code_length</i> holds the length of the machine code in bytes. 
</p>
<p>
	The machine code has been provided, but we know nothing about the code section it is located in. This information can be supplied by setting the instruction pointer and processor addressing mode inside the entry point structure (If you do not know what the instruction pointer, address size attribute or processor operating mode are, you definitely should at least read the following chapter: <a href="#un-entry-point">Understanding entry point</a>)
</p>
<p>
	The first required field of the entry point structure is <i><a href="api/structfcml__st__entry__point.html#af051b1f4faee0516e00180887e36fc31">op_mode</a></i> which describes the processor operating mode (16, 32 or 64 bit). We can also set default values for the address size attribute and operand size attribute for our virtual code segment. 
</p>
<pre class="brush: cpp">
context.entry_point.op_mode = op_mode;
context.entry_point.address_size_attribute = FCML_DS_UNDEF;
context.entry_point.operand_size_attribute = FCML_DS_UNDEF;
context.entry_point.ip = 0x00401000;
</pre>
<p>
	These defaults can be silently ignored because they set these attributes to 0 anyway.
</p>
<p>
	The disassembler context is almost initialized, but we have left the most important thing at the end. It is the disassembler itself. It has to be also put into the context, because it will be used to do the whole of the work. 
</p>
<pre class="brush: cpp">
context.disassembler = disassembler;
</pre>
<p>
	The next piece of code shows how the whole context initialization code should looks like:
</p>
<pre class="brush: cpp">
fcml_st_disassembler_context context = {0};
context.disassembler = disassembler;
context.configuration.enable_error_messages = FCML_TRUE;
context.configuration.short_forms = FCML_TRUE;
context.entry_point.op_mode = FCML_OM_32_BIT;
context.entry_point.address_size_attribute = 0;
context.entry_point.operand_size_attribute = 0;
context.entry_point.ip = 0x00401000;
context.code = code;
context.code_length = sizeof( code );
</pre>
<p>
	Now we are ready to disassemble the first piece of code, hence let's do it. In order to disassemble anything we have to call the function <i><a href="api/fcml__disassembler_8h.html#a26d4fb7b2eae675eeaaadbd950881c07">fcml_fn_disassemble</a></i>:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_disassemble( 
	fcml_st_disassembler_context *context, 
	fcml_st_disassembler_result *result );
</pre>
<p>
	The function gets a disassembler context and disassembler result as the function parameters, so let's set them to the instances we have prepared earlier:
</p>
<pre class="brush: cpp">
error = fcml_fn_disassemble( &amp;context, &amp;result );
if( !error ) {
	…
}
</pre>
<p>
	The function returns <i>FCML_CEH_GEC_NO_ERROR</i> if successful; otherwise an appropriate error code is returned. The result structure contains the disassembled instruction in the form of the generic instruction model and potential warning messages or error messages if the function failed.
</p>
<p>
	In addition there is a new structure which needs a little more attention here. It is the <i><a href="api/structfcml__st__instruction__details.html">fcml_st_instruction_details</a></i> structure which consists of additional information which is not relevant for the generic instruction model, but anyway can be useful through the process of the instruction analysis.
</p>

<h3 id="disassembler-analyse">Analysing instruction details</h3>
<p>
	As you probably already know, the disassembler decodes an instruction to the generic instruction model. It is very useful, because such a model is understandable by the assembler, so it can be then reassembled again. Either way it is a bit limited set of information, so there is another structure <i><a href="api/structfcml__st__instruction__details.html">fcml_st_instruction_details</a></i> which can be used to access more details about disassembled instructions. The following structure describes them:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_instruction_details {
	fcml_bool is_shortcut;
	fcml_bool is_pseudo_op;
	fcml_uint8_t instruction_code[FCML_INSTRUCTION_SIZE];
	fcml_usize instruction_size;
	fcml_st_prefixes_details prefixes_details;
	fcml_st_operand_details operand_details[FCML_OPERANDS_COUNT];
	fcml_st_decoded_modrm_details modrm_details;
	fcml_bool opcode_field_s_bit;
	fcml_bool opcode_field_w_bit;
	fcml_en_instruction instruction;
	fcml_en_pseudo_operations pseudo_op;
	fcml_uint16_t addr_mode;
	fcml_uint64_t instruction_group;
} fcml_st_instruction_details;
</pre>

<h4 id="disassembler-analyse-shortcuts">Shortcuts</h4>
<p>
	Two first two fields <i><a href="api/structfcml__st__instruction__details.html#a8174e580e3f7916f16f0c5b2d06bdc4d">is_shortcut</a></i> and <i><a href="api/structfcml__st__instruction__details.html#afcdf4fea7a85ccb67e592c33c9684364">is_pseudo_op</a></i> are related to the short instruction forms. The first one is always sets to <i>FCML_TRUE</i> if disassembled instruction is in its short form, so it needs the flag <i><a href="api/structfcml__st__disassembler__conf.html#a1f91b6e27453c19fe1896bb121f4ae87">short_forms</a></i> from the <i><a href="api/structfcml__st__disassembler__conf.html">fcml_st_disassembler_conf</a></i> structure to be set. 
</p>
<p>
	The second flag <i><a href="api/structfcml__st__instruction__details.html#afcdf4fea7a85ccb67e592c33c9684364">is_pseudo_op</a></i>  can be set for these instructions: CMPSD, VCMPSD, CMPSS, VCMPSS, VPCOMB, VPCOMW, VPCOMD, VPCOMQ, VPCOMUB, VPCOMUW, VPCOMUD, VPCOMUQ and is set only and only if their short forms called pseudo-ops are returned. For example:
</p>
<pre>
cmpsd xmm0,mmword ptr [rax+0000000000000020h],06h
cmpnlesd xmm0,xmm1
</pre>
<p>
	These two instructions describe the same piece of machine code <tt>0xF20FC2C106</tt>, but the field <i>is_pseudo_op</i> will be set to <i>FCML_TRUE</i> only for the second one (It also needs <i>short_forms</i> field to be set in the configuration.). Notice that they also differ on the level of operands. The second form has only two operands set in the GIM.
</p>

<h4 id="disassembler-analyse-machine-code">Instruction machine code</h4>
<p>
	The machine code of the instruction you have just disassembled is also accessible through two fields <i><a href="api/structfcml__st__instruction__details.html#a5548fd55c37b9915a60d5cf812a0e507">instruction_code</a></i> and <i><a href="api/structfcml__st__instruction__details.html#a7de997d330bc222adffebab785b350cb">instruction_size</a></i>. Obviously you have the same piece of machine code in your own array which is set in the disassembler context so this information is redundant, but it can be convenient to have it here if you collect disassembled instructions for further analysis.
</p>

<h4 id="disassembler-analyse-prefixes">Prefixes</h4>
<p>
	Every instruction can consist of more than one instruction prefix. Most assembler programmers are aware of explicit prefixes like REPNE or LOCK, but there are also prefixes like REX, VEX, XOP etc. which are not specified explicitly by the programmer in the source code. Anyway, it would be nice to have some information about them if they exist. 
</p>
<p>
	Some additional information about available prefixes is available through the field <i><a href="api/structfcml__st__instruction__details.html#a2247343a1370c881046dd3b8fc5f800a">prefixes_details</a></i> available directly in the disassembler result structure. These details are described by the following structure:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_prefixes_details {
	fcml_st_instruction_prefix prefixes[FCML_DASM_PREFIXES_COUNT];
	fcml_int prefixes_count;
	fcml_int prefixes_bytes_count;
	fcml_bool is_branch;
	fcml_bool is_nobranch;
	fcml_bool is_lock;
	fcml_bool is_rep;
	fcml_bool is_repne;
	fcml_bool is_xrelease;
	fcml_bool is_xacquire;
	fcml_bool is_vex;
	fcml_bool is_xop;
	fcml_bool is_rex;
	fcml_uint8_t vex_xop_first_byte;
	fcml_uint8_t r;
	fcml_uint8_t x;
	fcml_uint8_t b;
	fcml_uint8_t w;
	fcml_uint8_t l;
	fcml_uint8_t mmmm;
	fcml_uint8_t vvvv;
	fcml_uint8_t pp;
} fcml_st_prefixes_details;
</pre>

<p>
	The field <i><a href="api/structfcml__st__instruction__prefix.html#a634c5f1f9a8a7c3e8546a1670d6ca5f1">prefixes</a></i> is an array of the <i><a href="api/structfcml__st__instruction__prefix.html">fcml_st_instruction_prefix</a></i> structures. Field <i><a href="api/structfcml__st__prefixes__details.html#ad76b921aba809ce1dc512bb93b997913">prefixes_count</a></i> holds the number of really used elements in the array and the last one <i><a href="api/structfcml__st__prefixes__details.html#af27d3a28b71fb0daab32a36527258a25">prefixes_bytes_count</a></i> tells us how many bytes of the instruction code are really prefixes.
</p>
<p>
	So let's start with the <i><a href="api/structfcml__st__instruction__prefix.html">fcml_st_instruction_prefix</a></i> structure:
<p/>
<pre class="brush: cpp">
typedef struct fcml_st_instruction_prefix {
	fcml_uint8_t prefix;
	fcml_en_prefix_types prefix_type;
	fcml_bool mandatory_prefix;
	fcml_uint8_t vex_xop_bytes[2];
} fcml_st_instruction_prefix;
</pre>
<p>
	Every prefix consists of a <i><a href="api/structfcml__st__instruction__prefix.html#a634c5f1f9a8a7c3e8546a1670d6ca5f1">prefix</a></i> field which is a byte interpreted as a prefix, field <i><a href="api/structfcml__st__instruction__prefix.html#a74d9a35cc2ca9c3ae393e3b82fa90763">prefix_type</a></i> which is the type of the prefix (see below) and a <i><a href="api/structfcml__st__instruction__prefix.html#ac461fd85d0b504fc01978cbe1da23fe4">mandatory_prefix</a></i> flag which is set to <i>FCML_TRUE</i> for all mandatory prefixes (See Intel or AMD Architecture Manuals for more information about mandatory prefixes). The last field is <i><a href="api/structfcml__st__instruction__prefix.html#aa85fc9cca459b8fd9b6e10f0c75053bc">vex_xop_bytes</a></i> which is used in case of multi-byte VEX and XOP prefixes and contains second and the optionally third byte of the whole prefix.
</p>
<p>
	There are use cases when you are not really interested in any details about specific prefixes, but you would like to know if they exists or not. You can achieve it using the following lookup fields: <i>is_branch</i>, <i>is_nobranch</i>, <i>is_lock</i>, <i>is_rep</i>, <i>is_repne</i>, <i>is_xrelease</i>, <i>is_xacquire</i>, <i>is_vex</i>, <i>is_xop</i>, <i>is_rex</i>.
</p>
<p>
	The last category of fields exposed by <i><a href="api/structfcml__st__prefixes__details.html">fcml_st_prefixes_details</a></i> structure can be used to access common fields defined inside REX, XOP and VEX prefixes. These are: <i>r</i>, <i>x</i>, <i>b</i>, <i>w</i>, <i>l</i>, <i>mmmm</i> , <i>vvvv</i>, <i>pp</i>. It is a bit more advanced subject and if you are really interested in it do not hesitate to take a look at Intel or AMD Architecture Manuals, but you should not need it in the day-to-day usage.
</p>

<h4 id="disassembler-analyse-operand-details">Operand details</h4>
<p>
	The next structure <i><a href="api/structfcml__st__operand__details.html">fcml_st_operand_details</a></i> which is accessible through the field <i><a href="api/structfcml__st__instruction__details.html#a76603161a66f495c0d5f928fa8fd426e">operand_details</a></i> contains additional information about all operands available in the general instruction model. For now it consists of only one field <i><a href="api/structfcml__st__operand__details.html#a07b558c86c26a1590a14b4eacf07cb06">access_mode</a></i> which tells us if operand is <i>FCML_AM_READ</i>, <i>FCML_AM_WRITE</i> or <i>FCML_AM_READ_WRITE</i>.
</p>

<h4 id="disassembler-analyse-modrm">Details about ModR/M field</h4>
<p>
	The next structure <i><a href="api/structfcml__st__decoded__modrm__details.html">fcml_st_decoded_modrm_details</a></i> which is accessible through the field <i><a href="api/structfcml__st__instruction__details.html#a87d574d5550a18490e45e0ac44cf2c22">modrm_details</a></i> contains some details about the ModR/M:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_decoded_modrm_details {
	fcml_uint8_t modrm;
	fcml_nuint8_t sib;
	fcml_bool is_rip;
} fcml_st_decoded_modrm_details;
</pre>
<p>
	The first two fields are self-describable. The last one <i><a href="api/structfcml__st__decoded__modrm__details.html#ae6e35f2b5f97a4aac6287e04054c1f41">is_rip</a></i> is set to <i>FCML_TRUE</i> if the RIP addressing is used (only in 64-bit mode).
</p>

<h4 id="disassembler-analyse-fields">Instruction code and opcode fields</h4>
<p>
	The next four fields of the <i><a href="api/structfcml__st__instruction__details.html">fcml_st_instruction_details</a></i> structure are <i><a href="api/structfcml__st__instruction__details.html#a63e2975e0a2656208789e9ac04b56d3a">opcode_field_s_bit</a></i>, <i><a href="api/structfcml__st__instruction__details.html#a71202b255a11fef76a91f72110c456a2">opcode_field_w_bit</a></i>, <i><a href="api/structfcml__st__instruction__details.html#a95bc6efe12fea37c0091625df78d9806">instruction</a></i> and <i><a href="api/structfcml__st__instruction__details.html#a1eff49be68032cec6d20176ecbe55269">addr_mode</a></i>. The first two are set after the opcode fields 'w' and 's', but anyway they are set for informational purpose only and you should not use them for any critical functionality. You can treat them as deprecated fields and as such they will be probably removed in the future releases.
</p>
<p>
	The third field <i><a href="api/structfcml__st__instruction__details.html#a95bc6efe12fea37c0091625df78d9806">instruction</a></i> stores an instruction code. Every instruction has its own code which is declared in the <i><a href="api/fcml__instructions_8h.html">fcml_instructions.h</a></i> header file. For instance <i>F_ADD</i>, <i>F_CALL</i>, <i>F_DIV</i>. These codes are more convenient than mnemonics when we only need to identify the type of the instruction. 
</p>
<p>
	The fourth field defines instruction form being used to disassemble the code. For instance: <i>FCML_AM_RM8_IMM8</i> or <i>FCML_AM_RMO_RO</i>. They are used internally but can be also useful together with the instruction codes to identify not only the instruction but also its form. Anyway you should not rely on it, because there are instructions which do not specify the forms, even if there are any.
</p>

<h4 id="disassembler-instruction-groups">Instruction groups</h4>

The last field <i><a href="api/structfcml__st__instruction__details.html#ab3268b1f798e301d3e3e1607a8abf9cd">instruction_group</a></i> can be used to identify an instruction group. The instruction group is used to classify instructions. Groups are just bit masks, so every instruction can be a member of more than one group. All groups are defined in the <i><a href="api/fcml__instructions_8h.html">fcml_instructions.h</a></i> header file.
<pre class="brush: cpp">
#define 	FCML_AMT_UNDEF   0x0000000000000000UL
#define 	FCML_AMT_SSEx   0x0000000000000001UL
#define 	FCML_AMT_VEXx   0x0000000000000002UL
#define 	FCML_AMT_SIMD   0x0000000000000004UL
#define 	FCML_AMT_GPI   0x0000000000000008UL
#define 	FCML_AMT_FPU   0x0000000000000010UL
#define 	FCML_AMT_MMX   0x0000000000000020UL | FCML_AMT_SSEx
#define 	FCML_AMT_SSE   0x0000000000000040UL | FCML_AMT_SSEx
#define 	FCML_AMT_SSE2   0x0000000000000080UL | FCML_AMT_SSEx
#define 	FCML_AMT_SSE3   0x0000000000000100UL | FCML_AMT_SSEx
#define 	FCML_AMT_SSSE3   0x0000000000000200UL | FCML_AMT_SSEx
#define 	FCML_AMT_SSE41   0x0000000000000400UL | FCML_AMT_SSEx
#define 	FCML_AMT_SSE42   0x0000000000000800UL | FCML_AMT_SSEx
#define 	FCML_AMT_SSE4A   0x0000000000001000UL | FCML_AMT_SSEx
#define 	FCML_AMT_AVX   0x0000000000002000UL | FCML_AMT_VEXx
#define 	FCML_AMT_AVX2   0x0000000000004000UL | FCML_AMT_VEXx
#define 	FCML_AMT_AES   0x0000000000008000UL
#define 	FCML_AMT_SYSTEM   0x0000000000010000UL
#define 	FCML_AMT_3DNOW   0x0000000000020000UL | FCML_AMT_MMX
#define 	FCML_AMT_TBM   0x0000000000040000UL | FCML_AMT_VEXx
#define 	FCML_AMT_BMI1   0x0000000000080000UL
#define 	FCML_AMT_BMI2   0x0000000000100000UL
#define 	FCML_AMT_HLE   0x0000000000200000UL
#define 	FCML_AMT_ADX   0x0000000000400000UL
#define 	FCML_AMT_CLMUL   0x0000000000800000UL
#define 	FCML_AMT_F16C   0x0000000001000000UL | FCML_AMT_VEXx
#define 	FCML_AMT_RDRAND   0x0000000002000000UL
#define 	FCML_AMT_RDSEED   0x0000000004000000UL
#define 	FCML_AMT_PRFCHW   0x0000000008000000UL
#define 	FCML_AMT_LWP   0x0000000010000000UL | FCML_AMT_SIMD
#define 	FCML_AMT_SVM   0x0000000020000000UL
#define 	FCML_AMT_FSGSBASE   0x0000000040000000UL
#define 	FCML_AMT_FMA   0x0000000080000000UL | FCML_AMT_SIMD
#define 	FCML_AMT_FMA4   0x0000000100000000UL | FCML_AMT_SIMD
#define 	FCML_AMT_XOP   0x0000000200000000UL | FCML_AMT_SIMD
#define 	FCML_AMT_EDX   0x0000000400000000UL
#define 	FCML_AMT_ABM   0x0000000800000000UL
#define 	FCML_AMT_VMX   0x0000001000000000UL
#define 	FCML_AMT_SMX   0x0000002000000000UL
#define 	FCML_AMT_POPCNT   0x0000004000000000UL
#define 	FCML_AMT_RTM   0x0000008000000000UL
#define 	FCML_AMT_CTI   0x0000010000000000UL
#define 	FCML_AMT_BRANCH   0x0000020000000000UL
#define 	FCML_AMT_MMX_SIMD   FCML_AMT_MMX | FCML_AMT_SIMD
#define 	FCML_AMT_SSE_SIMD   FCML_AMT_SSE | FCML_AMT_SIMD
#define 	FCML_AMT_SSE2_SIMD   FCML_AMT_SSE2 | FCML_AMT_SIMD
#define 	FCML_AMT_SSE3_SIMD   FCML_AMT_SSE3 | FCML_AMT_SIMD
#define 	FCML_AMT_SSSE3_SIMD   FCML_AMT_SSSE3 | FCML_AMT_SIMD
#define 	FCML_AMT_SSE41_SIMD   FCML_AMT_SSE41 | FCML_AMT_SIMD
#define 	FCML_AMT_SSE42_SIMD   FCML_AMT_SSE42 | FCML_AMT_SIMD
#define 	FCML_AMT_AVX_SIMD   FCML_AMT_AVX | FCML_AMT_SIMD
#define 	FCML_AMT_AVX2_SIMD   FCML_AMT_AVX2 | FCML_AMT_SIMD
#define 	FCML_AMT_3DNOW_SIMD   FCML_AMT_3DNOW | FCML_AMT_SIMD
</pre>
<p>
	For instance CALL instruction is a member of the following groups: <i>FCML_AMT_GPI</i> (General purpose instruction), <i>FCML_AMT_CTI</i> (Controll transfer instruction), <i>FCML_AMT_BRANCH</i> (Branch instruction). 
</p>
<p>
	Notice that they are not always related to the CUID flags.
</p>

<h3 id="disassembler-free">Freeing resources</h3>
<p>
	When resources used by the disassembler are no longer needed they have to be freed. The following code frees a disassembler instance, disassembler result and dialect.
</p>
<pre class="brush: cpp">
fcml_fn_disassembler_result_free( &amp;result );
fcml_fn_disassembler_free( disassembler );
fcml_fn_dialect_free( dialect );
</pre>
<p>
	Remember that <i><a href="api/fcml__disassembler_8h.html#aacd6d5618c7e460cde65188c5c8ba241">fcml_fn_disassembler_result_free</a></i> function does not free the result structure itself. It is only responsible for freeing all structures allocated by the disassembler which are accessible through the disassembler result, as error messages for instance. It is why such a structure can be still reused by the disassembler even if it was freed before.
</p>

<h2 id="instruction-renderer">Instruction renderer</h2>
<p>
	Instruction renderers are used to generate textual representation of assembled instructions. All you need to do is to configure instruction renderer and render a disassembler result into a provided text buffer. So let's do it, but at first take a look at the function we will use to render the instruction model:
</p>
<pre class="brush: cpp">
LIB_EXPORT fcml_ceh_error LIB_CALL fcml_fn_render( 
	fcml_st_dialect *dialect, 
	fcml_st_render_config *config, 
	fcml_char *buffer, 
	fcml_usize buffer_len, 
	fcml_st_disassembler_result *result );
</pre>
<p>
	This function needs quite a few arguments but take into account that there is only one argument that have to be carefully prepared. It is the <i><a href="api/structfcml__st__render__config.html">fcml_st_render_configstructure</a></i> which configures some aspects of the rendering process:
</p>
<pre class="brush: cpp">
typedef struct fcml_st_render_config {
	fcml_uint32_t render_flags;
	fcml_uint16_t prefered_mnemonic_padding;
	fcml_uint16_t prefered_code_padding;
} fcml_st_render_config;
</pre>
<p>
	It is not so complicated, because it contains only a few rendering flags and the padding configuration for the mnemonic and instruction code (If instruction code is rendered). The padding fields are described together with the rendering flags <i>FCML_REND_FLAG_CODE_PADDING</i> and <i>FCML_REND_FLAG_MNEMONIC_PADDING</i>.
</p>
<p>
	The following list describes all available rendering flags:
</p>
<dl>
	<dt>FCML_REND_FLAG_RENDER_CODE<dt>
	<dd>
		<p>
			If this flag is set, the instruction code is rendered. For instance: "<span class="instruction"><b>666781d04280</b> adc ax,32834</span>".
		</p>
	</dd>
	<dt>FCML_REND_FLAG_HEX_IMM<dt>
	<dd>
		<p>
			If this flag is set, the immediate operands are rendered as hexadecimal literals: "<span class="instruction">adc rax,<b>0000000042806521h</b></span>".
		</p>
	</dd>
	<dt>FCML_REND_FLAG_RENDER_DEFAULT_SEG<dt>
	<dd>
		<p>
			If this flag is set, the segment register is rendered even if there is only the default one: "<span class="instruction">call far fword ptr <b>cs:</b>[ebx+00000001h]</span>".
		</p>
	</dd>
	<dt>FCML_REND_FLAG_HEX_DISPLACEMENT<dt>
	<dd>
		<p>
			The displacement value is rendered as hexadecimal literal: "<span class="instruction">adc byte ptr [ecx+eax+<b>00000002h</b>],03h</span>".
		</p>
	</dd>
	<dt>FCML_REND_FLAG_COND_GROUP_1/2<dt>
	<dd>
		<p>
			These flags can be used to choose a set of conditional suffixes used when rendering conditional mnemonics. In general there are two groups available "Group 1" and "Group 2" as has been shown in the table below. So these flags are disjunctive.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_COND_SHOW_CARRY<dt>
	<dd>
		<p>
			When conditional suffix group is already chosen you can also enable carry suffixes for two conditions. See "Show carry" column in the table below.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_RENDER_SIB_HINT<dt>
	<dd>
		<p>
			If this flag is set, the SIB hint will be rendered. Supported by the Intel syntax only: "<span class="instruction">add dword ptr [<b>sib</b> eax],eax</span>". Ignored in case of the AT&amp;T dialect.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_RENDER_ABS_HINT<dt>
	<dd>
		<p>
			If this flag is set and the absolute addressing is used, "abs" hint will be rendered: "<span class="instruction">rcl byte ptr [<b>abs</b> 0000000000401007h],03h</span>". Ignored in case of the AT&amp;T dialect.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_RENDER_REL_HINT<dt>
	<dd>
		<p>
			If this flag is set and the relative addressing is used, "rel" hint will be rendered: "<span class="instruction">rcl byte ptr [<b>rel</b> 0000800000401007h],03h</span>". Ignored in case of the AT&amp;T dialect.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_RENDER_INDIRECT_HINT<dt>
	<dd>
		<p>
			If this flag is set and the indirect addressing mode is used, "indirect" hint will be rendered: "<span class="instruction">jmp indirect dword ptr [eax]</span>". Ignored in case of the AT&amp;T dialect.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_CODE_PADDING<dt>
	<dd>
		<p>
			If this flag is set a code padding is rendered. The code padding is a fixed space between the instruction code and the mnemonic. For instance  the following instruction has been rendered for the code padding set to 10, so there have to be minimum 10 * 2 characters rendered before the mnemonic: "<span class="instruction">6681d04280&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; adc ax,32834</span>". The code padding can be configured using the <i><a href="api/structfcml__st__render__config.html#a15993249b0ddc23025b147178cef6ed5">prefered_code_padding</a></i> configuration field.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_MNEMONIC_PADDING<dt>
	<dd>
		<p>
			If this flag is set a mnemonic padding is added. The mnemonic padding is a fixed space between the mnemonic and the first operand. For example the following instruction has been rendered with the mnemonic padding set to 8: "<span class="instruction">6681d04280 adc&nbsp;&nbsp;&nbsp;&nbsp; ax,32834</span>". Take into account that there are 8 characters between the start of the mnemonic and the first operand. The mnemonic padding can be configured using the <i><a href="api/structfcml__st__render__config.html#a8ae45e5aa50f04a0ecd8a51090b88f3e">prefered_mnemonic_padding</a></i> configuration field.
		</p>
	</dd>
	<dt>FCML_REND_FLAG_REMOVE_LEADING_ZEROS<dt>
	<dd>
		<p>
			If the flag is set, renderer removes leading zeros from all integer literals. For example the following instruction: "<span class="instruction">call far fword ptr cs:[ebx+00000001h]</span> will be rendered as: "<span class="instruction">call far fword ptr cs:[ebx+1h]</span>".
		</p>
	</dd>
	<dt>FCML_REND_DEFAULT_FLAGS<dt>
	<dd>
		<p>
			It can be used if we do not want to set any rendering flags.
		</p>
	</dd>
</dl>
<p>
	The following table shows mentioned conditional suffixes groups:
</p>

<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<caption>Conditional prefixes groups</caption>
		<thead>
			<tr>
				<th>Group 1</th>
				<th>Group 2</th>
				<th>Show carry</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>o</td>
				<td>o</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>no</td>
				<td>no</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>b</td>
				<td>nae</td>
				<td>c</td>
			</tr>
			<tr>
				<td>nb</td>
				<td>ae</td>
				<td>nc</td>
			</tr>
			<tr>
				<td>e</td>
				<td>z</td>
				<td></td>
			</tr>
			<tr>
				<td>ne</td>
				<td>nz</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>be</td>
				<td>na</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>nbe</td>
				<td>a</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>s</td>
				<td>s</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>ns</td>
				<td>ns</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>p</td>
				<td>pe</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>np</td>
				<td>po</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>l</td>
				<td>nge</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>nl</td>
				<td>ge</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>le</td>
				<td>ng</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			<tr>
				<td>nle</td>
				<td>g</td>
				<td>Group 1 or Group 2.</td>
			</tr>
			
		</tbody>
	</table>
</div>
<p>
	This is an example of a very basic configuration:
</p>
<pre class="brush: cpp">
fcml_st_render_config render_config = {0};
render_config.render_flags = FCML_REND_FLAG_HEX_IMM | FCML_REND_FLAG_HEX_DISPLACEMENT;
</pre>
<p>
	To get back to the rendering function, the two arguments that follow configuration: <i>buffer</i> and <i>buffer_length</i> point to the destination text buffer where textual representation of the instruction will be written. You can allocate the destination buffer this way for example:
</p>
<pre class="brush: cpp">
fcml_uint8_t buffer[FCML_INSTRUCTION_SIZE];
</pre>
<p>
	Remember that this buffer is also a reusable one and does not have to be cleaned between multiple calls to the rendering function.
</p>
<p>
	We have prepared all needed arguments, so let's render the result:
</p>
<pre class="brush: cpp">
fcml_ceh_error error;
error = fcml_fn_render( dialect, render_config, buffer, sizeof( buffer ), result );
</pre>
<p>
	Notice that we pass the whole disassembler result structure to the renderer. It is important to note that in order to render the instruction the GIM is not enough, it is why the whole result is passed as the argument, because it contains <i><a href="api/structfcml__st__instruction__details.html">fcml_st_instruction_details</a></i> structure which is also used by the renderer. 
</p>
<p>
	Although it is possible to prepare such a disassembler result by hand and pass it the renderer, it would be very risky. Just remember to use the renderer only with structures prepared by the FCML disassembler. The last thing you need to know is the fact that you have to use the same dialect that was used by the disassembler.
</p>
<p>
	The following example disassembles a piece of code and renders it to the console:
</p>
<pre class="brush: cpp">
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#include &lt;fcml/fcml_disassembler.h&gt;
#include &lt;fcml/fcml_renderer.h&gt;
#include &lt;fcml/fcml_intel_dialect.h&gt;

int main(int argc, char **argv) {

	fcml_int8_t code[] = { 0x4D, 0x11, 0x64, 0x89, 0x01 };

	fcml_ceh_error error;

	/* Initializes Intel dialect instance. */
	fcml_st_dialect *dialect;
	if( ( error = fcml_fn_dialect_init_intel( FCML_INTEL_DIALECT_CF_DEFAULT, &amp;dialect ) ) ) {
		fprintf( stderr, "Can not initialize Intel dialect: %d", error );
		exit(1);
	}

	/* Initializes a disassembler for the Intel dialect. */
	fcml_st_disassembler *disassembler;
	if( ( error = fcml_fn_disassembler_init( dialect, &amp;disassembler ) ) ) {
		fprintf( stderr, "Can not initialize disassembler: %d", error );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	/* Prepares a disassembler result. */
	fcml_st_disassembler_result dis_result;
	fcml_fn_disassembler_result_prepare( &amp;dis_result );

	/* Disassembles the code. */
	fcml_st_disassembler_context context = {0};
	context.disassembler = disassembler;
	context.entry_point.ip = 0x401000;
	context.entry_point.op_mode = FCML_OM_64_BIT;
	context.code = code;
	context.code_length = sizeof( code );

	if( ( error = fcml_fn_disassemble( &amp;context, &amp;dis_result ) ) ) {
		fprintf( stderr, "Can not disassemble the code: %d", error );
		fcml_fn_disassembler_free( disassembler );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	/* Renders the disassembled instruction. */
	fcml_char buffer[FCML_REND_MAX_BUFF_LEN];

	fcml_st_render_config config = {0};
	if( ( error = fcml_fn_render( dialect, &amp;config, buffer, sizeof( buffer ), &amp;dis_result ) ) ) {
		fprintf( stderr, "Can not disassemble the code: %d", error );
		fcml_fn_disassembler_result_free( &amp;dis_result );
		fcml_fn_disassembler_free( disassembler );
		fcml_fn_dialect_free( dialect );
		exit(1);
	}

	printf( "Instruction: %s\n", buffer );

	/* Free everything. */
	fcml_fn_disassembler_result_free( &amp;dis_result );
	fcml_fn_disassembler_free( disassembler );
	fcml_fn_dialect_free( dialect );

}
</pre>
<p>
	It should print something like this:
</p>
<pre>
Instruction: adc qword ptr [r9+rcx*4+1],r12
</pre>

<h1 id="cpp-wrapper">CPP Wrapper</h1>
<p>
	Since FCML 1.1.0 there is a C++ wrapper available. The whole implementation is placed in header files which are located next to their C counterparts. The core of FCML library still exports only C symbols which are then used by the wrapper implementation internally. The main advantage of this approach is the fact that anyone can use the wrapper even if there is only C version of the FCML on a particular system. The implementation is based on the following goals and assumptions:
</p>
<ul class="feature-list">
	<li>The wrapper has to be easy in use.</li>
	<li>The performance is not the main goal here. If you really need the best performance possible, you should definitely consider using the C API directly. Anyway it does not mean that it is slow. It can be just a bit slower that proper C implementation, maintly because C++ data structures are often being copied just to make the usage easier. See the next point.</li>
	<li>If it is possible to copy or assign an object you can be sure that the deep copy is being made and the two objects being the result of the operation are completely independent and can be freed whenever you want (There is one exception from this rule and it is documented later, see: CodeIterator class). It can hit the performance a bit, so you have to bear it in mind that C structures are always copied to the C++ objects. In most cases there are no wrappers around the structures directly. It is the most important assumption here and it will not be changed in future releases. For instance the whole fcml_st_assembler_result is always copied to the fcml::AssemblerResult after every call to the assembler.</li>
	<li>If for whatever reason an object cannot be deep copied C++ compiler just will not allow you to do so. The <i><a href="api/classfcml_1_1Assembler.html">Assembler</a></i> class is a good example of such a class. It maintains a real instance of <i><a href="api/fcml__assembler_8h.html#a07ef99f7c08004280dfe87f302f62f28">fcml_fn_assemble</a></i> structre which cannot be copied just like that.</li>
	<li>Strings are always wrapped in the <i>fcml::fcml_cstring</i>, so you do not have to track them.</li>
	<li>Build-in exceptions are ALWAYS thrown using references. It's event not possible to allocate them using the “new” operator.</li>
	<li>Some of the C enumeration types are wrapped in the new types declared directly in the classes using them (just to make them more convenient to use).</li>
	<li>There might be CPP files that can be included just to compile and link some definitions into the destination object files, but they are here due to the convenience and they are optional, so it is your decision to use them or not.</li>
	<li>Most of the C structures have their CPP counterparts placed in header files with “.hpp” extensions.</li>
	<li> Everything dedicated to the C++ is available in the fcml name space.</li>
</ul>

<p>
	The documentation of the wrapper is not as detailed as the rest of the FCML manual, thus you should undoubtedly read the C part if your goal is to master the library. The wrapper code is really simple so when you are not so sure if something is allowed or not do not hesitate to take a look at the source code and the API documentation. Do not be fooled by the size of the wrapper code. There are a lot of helper methods and accessors over there which are really simple, but they make the code significantly bigger. Of course you can always help improving the manual and make it more detailed if you have time and will.
</p>
<p>
	Ok, that's enough talking. Let's get started!
</p>

<h2 id="cpp-mnemonics">Mnemonics</h2>
<p>
There are two header files prepared for the C++ wrapper. It's <i><a href="api/fcml__gas__mnemonics_8hpp.html">fcml_gas_mnemonics.hpp</a></i> and <i><a href="api/fcml__intel__mnemonics_8hpp.html">fcml_intel_mnemonics.hpp</a></i>. They declare constant strings with all mnemonics supported by the available dialects. The convention is really simple. Every mnemonic is prefixed with M_. For example these all are valid instruction mnemonics: <i>M_ADD</i>, <i>M_CALL</i>, <i>M_SUB</i> and so on. This prefix is a bit inconvenient and definitely can be seen as completely unnecessary here, but some of the mnemonics like OUT or IN fall in conflict with pre-processor macros which are defined by Microsoft compilers form example. Of course it is an open source project so you are welcome to take the code and modify it for your purposes. As far as I remember there are no conflicts in case of GNU compilers. I haven't checked clang yet.
</p>
<p>
	There is one more thing you have to do in order to make it work. As you probably already know the wrapper is implemented using header files only so there are no C++ symbols exported by the FCML library. Due to this hmm restriction? you have to include definitions of these mnemonics exactly once in your own source code. It is as simple as including every regular header file:
</p>

<pre class="brush: cpp">
#include &lt;fcml_gas_mnemonics.cpp&gt;
int main() {
    return 0;
}
</pre>
<p>
	Remember to include them only once. They do not have to be included in every file which uses mnemonics. In fact doing so would lead to symbols duplication errors while the application is compiling. 
</p>
<p>
	For Intel mnemonics use <i><a href="api/fcml__intel__mnemonics_8cpp.html">fcml_intel_mnemonics.cpp</a></i>
</p>
<p>
If you really need to use GAS and Intel mnemonics together, just fell free to do it, but you have to be aware that they use different name spaces: <i>fcml::intel</i> and <i>fcml:gas</i>.
<p>
<p>
In case you are sceptical about including implementation files you can always use plain C header files <i><a href="api/fcml__gas__mnemonics_8h.html">fcml_gas_mnemonics.h</a></i> and <i><a href="api/fcml__intel__mnemonics_8h.html">fcml_intel_mnemonics.h</a></i> which declares mnemonics using preprocessor directives, but remember that using mnemonics dedicated to C++ you can gain some performance, because <i>fcml_cstring</i> instances do not need to be created implicitly if methods or operators expect them (every mnemonic is just a constant <i>fcml_cstring</i>).
</p>
<h2 id="cpp-common-types">Common types</h2>
<p>
	This chapter describes important common types which are used by the rest of wrapper classes. They are not described in every detail because lots of them are full of various utility methods and operators, so the best way to master them is to head over to the API documentation.
</p>

<h3 id="cpp-common-types-cpp-character-types">Character types</h3>
<p>
	There are two new type declarations for character types. The first one is <i>fcml::fcml_cstring</i> which is just <i>std::basic_string</i> for <i>fcml_char</i> type. It can be used alternatively with the standard <i>std::string</i> as long as the fcml_char is a standard C character type. For now UNICODE support is still in the plans (and will be probably available soon), so it does not matter which configuration you use (ASCII/UNICODE in case of VS), because <i>fcml::fcml_cstring</i> is always a char based type like the <i>std:string</i>. So regardless of the chosen configuration it should be possible to use <i>std:string</i> and </i>fcml::fcml_cstring</i> alternatively. 
</p>
<p>
	However you should bear in mind that using the <i>fcml::fcml_cstring</i> is more portable and as so choosing it can lead to significant advantages if your source code will be ported to the UNICODE in the future. In the next releases <i>fcml_char</i> will probably be configuration dependant and might not be convertible directly to the <i>std:string</i>. For now just remember that <i>fcml::fcml_cstring</i> is an 8-bit ASCII, not UNICODE type. Remember that UNICODE characters are two byte or more in length and are represented as words.
</p>
<p>
	The second type <i>fcml::fcml_costream</i> is just an output string stream based on the <i>std::basic_ostringstream</i> and <i>fcml_char</i> type.
</p>

<h3 id="cpp-common-types-cpp-entry-point-class">EntryPoint class</h3>
<p>
    The <a href="api/classfcml_1_1EntryPoint.html">class</a> holds information about an entry point. It is just a counterpart to the <i><a href="api/structfcml__st__entry__point.html">fcml_st_entry_point</a></i> structure. In most cases this class is used indirectly and its usage is just hidden from the user. In order to create an entry point instance directly use the following piece of code:
</p>
<pre class="brush: cpp">
    EntryPoint entryPoint( EntryPoint::OM_32_BIT, 0x401000 );
</pre>
<p>
    Both address size attribute and operand size attribute can be also provided as optional parameters.
</p>

<h3 id="cpp-common-types-cpp-integer-class">Integer class</h3>
<p>
    It is counterpart to the <i><a href="api/structfcml__st__integer.html">fcml_st_integer</a></i> structure. It is a bit complex class and you should definitely take a look at the <a href="api/classfcml_1_1Integer.html">API</a> as well as the source code in order to understand it deeply. In short words it wraps an integer value of a particular size and has a sign. In most cases they can be used as ordinal integer types provided by the compiler, because implementations of the most important operators are provided. Take a look at the following piece of code:
</p>
<pre class="brush: cpp">
Integer v1 = static_cast&lt;fcml_uint8_t&gt;( 10 );
Integer v2 = static_cast&lt;fcml_uint8_t&gt;( 20 );

fcml_uint8_t sum = v1 + v2;

sum == 30 // True
</pre>
<p>
    It creates two integers. The first one is an 8-bit unsigned integer with the value of 10. The second one is set to 20 and is also an 8-bit unsigned value. They are then added to each other and the result is then stored in a new Integer.
</p>
<p>
    Remember that the result is always of the size and type of the first operand. For instance:
</p>
<pre class="brush: cpp">
Integer v1 = (fcml_uint8_t)20;
Integer v2 = (fcml_int64_t)10;


Integer sum = v1 + v2;

sum == 30 // True
!sum.isSigned() // True
sum.getSize() == 8 // True
</pre>
<p>
    In such a case the result “sum” is an 8 bit unsigned value set to 30.
</p>

<h3 id="cpp-common-types-cpp-register-class">Register class</h3>
<p>
    It is a direct counterpart to the <i><a href="api/structfcml__st__register.html">fcml_st_register</a></i> structure. It has the same members and they have the same meaning. In order to create a register instance you can use the constructor directly:
</p>
<pre class="brush: cpp">
Register regCons( FCML_REG_AL, FCML_DS_8 );
</pre>
<p>
    You can also use static factory methods provided by the <i><a href="api/classfcml_1_1Register.html">fcml::Register</a></i> class:
</p>
<pre class="brush: cpp">
Register reg = Register::AL();
const Register &amp;reg = Register::AL();
</pre>
<p>
    It is a convenient way of creating all the registers, but there is even a simpler way of doing it. All you have to do is to include the following header files: <i><a href="api/fcml__registers_8hpp.html">fcml_registers.hpp</a></i> and <i><a href="api/fcml__registers_8cpp.html">fcml_registers.cpp</a></i>. It is very important to include the *.cpp file only once to avoid duplicated symbols. The main project file is the best place for including it. After doing so you gain access to the constant variables for all registers that can be directly acceded:
</p>
<pre class="brush: cpp">
#include &lt;fcml_registers.hpp&gt;
#include &lt;fcml_registers.cpp&gt;

const Register &amp;reg = AL;
if( reg == Register::AL() ) {
}
</pre>
<p>
    Unlike the .cpp file, .hpp header has to be visible in every source file which accesses the registers.
</p>

<h2 id="cpp-generic-instruction-model">Generic instruction model</h2>
<p>
    All class related to generic instruction models are strict counterparts to the C structures: <i><a href="api/classfcml_1_1FarPointer.html">FarPointer</a></i>, <i><a href="api/classfcml_1_1SegmentSelector.html">SegmentSelector</a></i>, <i><a href="api/classfcml_1_1EffectiveAddress.html">EffectiveAddress</a></i>, <i><a href="api/classfcml_1_1Address.html">Address</a></i>, <i><a href="api/classfcml_1_1Operand.html">Operand</a></i>, <i><a href="api/classfcml_1_1Condition.html">Condition</a></i>, <i><a href="api/classfcml_1_1Instruction.html">Instruction</a></i>.
</p>
<p>
    The following examples show how they can be allocated:
</p>

<h3 id="cpp-generic-instruction-model-cpp-far-pointer">Far pointer</h3>
<p>
    A far pointer class instance can be allocated using the constructor or two factory methods. The first method creates a far pointer for a 32-bit offset while the second one for a 16-bit one:
</p>
<pre class="brush: cpp">
FarPointer fp = FarPointer(0x3000, 0x000401000 );
fp = FarPointer::off32( 0x3000, 0x000401000 );
fp = FarPointer::off16( 0x3000, 0x01212 );
</pre>

<h3 id="cpp-generic-instruction-model-cpp-segment-selector">Segment selector</h3>
<p>
    Using the constructor to allocate segment selector:
</p>
<pre class="brush: cpp">
SegmentSelector ss(Register::CS(),true);
</pre>
<p>
    A static factory method is also available here:
</p>
<pre class="brush: cpp">
SegmentSelector::seg( Register::CS(),true );
</pre>
<p>
    The first parameter represents a segment register, the second one should be set to true if the segment selector sets the default segment register in the given context.
</p>

<h3 id="cpp-generic-instruction-model-cpp-effective-address"a>Effective address</h3>
<p>
    Effective addresses can be created using constructors, but there are also factory methods which can be used to prepare every allowed combination of the effective address components. Take a look at the <a href="api/classfcml_1_1EffectiveAddress.html">API</a> to master all the ways of allocating it. The following code shows few examples:
</p>
</p>
    Using the constructor:
</p>
<pre class="brush: cpp">
EffectiveAddress base( Register::EAX() );
</pre>
<p>
    Using the factory methods:
</p>
<pre class="brush: cpp">
EffectiveAddress base_disp = EffectiveAddress::addr( EAX, Integer::int8(0x40) );
EffectiveAddress base_index = EffectiveAddress::addr( EAX, EDX );
EffectiveAddress base_index_scale = EffectiveAddress::addr( EAX, EDX, 4 );
</pre>

<h3 id="cpp-generic-instruction-model-cpp-addresses">Addresses</h3>
<p>
    <i><a href="api/classfcml_1_1Address.html">Address</a></i> class represents relative and absolute offsets as well as an effective addresses. The constructor and factory methods can be used alternatively to create instances of the class. Some of the factory methods uses <i><a href="api/classfcml_1_1EffectiveAddress.html">fcml::EffectiveAddress</a></i> class internally, so you do not have to allocate it explicitly in order to prepare the effective address:
</p>
<p>
A relative or absolute offset:
</p>
<pre class="brush: cpp">
Address address(0x401000);
</pre>
<p>
    An effective address using factory method from the EffectiveAddress class:
</p>
<pre class="brush: cpp">
Address effective(EffectiveAddress::addr(EAX(), FCML_DS_32));
</pre>
<p>
    The same effective address using the factory method provided directly by the Address class:
</p>
<pre class="brush: cpp">
Address effective = Address::effective(EAX, FCML_DS_32)
</pre>

<h3 id="cpp-generic-instruction-model-cpp-conditions">Conditions</h3>
<p>
    <i><a href="api/classfcml_1_1Condition.html">fcml::Condition</a></i> is a class that represents a condition which is used to describe conditional instructions like conditional branches. It's really rare when instances of the <i>Condition</i> class have to be created manually, but if you really need to do it, use the provided constructor or factory methods as follows:
</p>
<p>
    Constructor:
</p>
<pre class="brush: cpp">
Condition condition( Condition::CONDITION_LE, true );
</pre>
<p>
    Factory methods:
</p>
<pre class="brush: cpp">
Condition condition = Condition::NLE()
</pre>
<p>
    The most important thing here is the fact that there are a lot of helpful methods which can be used to check the condition type. For instance:
</p>
<pre class="brush: cpp">
Condition condition( Condition::CONDITION_LE, true );
if( condition.isNLE() ) {
}
if( condition == Condition::NLE() ) {
}
if( condition.isNegation() ) {
}
</pre>
<p>
    In the first and second example we just compare the whole condition. The third example checks if the condition is a negation of a particular condition type, <b>LE</b> in this case.
</p>

<h3 id="cpp-generic-instruction-model-cpp-operands">Operands</h3>
<p>
    <i><a href="api/classfcml_1_1Operand.html">fcml::Operand</a></i> class is built in the same way as the <i><a href="api/structfcml__st__operand.html">fcml_st_operand</a></i> structure. There is a type and aggregated objects describing every possible type of a operand. The following examples describe ways operands can be created:
</p>
<p>
    Constructors:
</p>
<pre class="brush: cpp">
Operand imm( 0x201000 );
Operand far_ptr( FarPointer( 0x1020, (fcml_int16_t)0x3030 ) );
</pre>
<p>
    Some methods dedicated to set up certain types of the operands:
</p>
<pre class="brush: cpp">
Operand operand;
operand.far_ptr( FarPointer( 0x1020, (fcml_int16_t)0x3030 ) );
operand.addr( EffectiveAddress( Register::EAX() ) );
</pre>
<p>
    Take a look at the <a href="api/classfcml_1_1Operand.html">API</a> to see all of them.
</p>
<p>
There is also an operand builder class fcml:OB which is strictly dedicated to creation of operands by exposing static factory methods:
</p>
<pre class="brush: cpp">
Operand eff = OB::addr( EffectiveAddress( Register::EAX() ) );
Operand eff = OB::eff( EAX, 8 );
Operand reg = OB::reg( ECX );
Operand imm = OB::imm( 0x401000 );
Operand farp = OB::far_ptr( 0x1020, (fcml_int16_t)0x3030 );
</pre>

<h3 id="cpp-generic-instruction-model-cpp-instructions">Instructions</h3>
<p>
Until now we have discussed all parts of the generic instruction model, so it is time to create some instructions using them. Of course instructions can be prepared using constructors directly, but there are no factory methods in the <i><a href="api/classfcml_1_1Instruction.html">fcml:Instruction</a></i> class like in the other cases. Instead, there is another class <i><a href="api/classfcml_1_1IB.html">fcml:IB</a></i>. It is a stateful instruction builder which is destined to prepare instructions in a bit more convenient way. So let's see some examples:
</p>
<p>
For the sake of this example let's try to build the following instruction by hand: "<span class="instruction">mov byte ptr [eax], ecx</span>".
</p>
<p>
    The first way using the constructor with an instruction mnemonic and some factory methods adding  operands. If the builder state is complete, the instruction itself can be built using the <i>"build()"</i>  method:
</p>
<pre class="brush: cpp">
Instruction instruction;
instruction = IB( M_MOV ).eff( EAX, 8 ).reg( ECX ).build();
</pre>
<p>
    The last method is optional and the whole code might look like this:
</p>
<pre class="brush: cpp">
instruction = IB::inst( M_MOV ).eff( EAX, 8 ).reg( ECX );
</pre>
<p>
    As you can see the instruction builder itself is created a bit differently in this case using the static factory method <i>"inst()"</i>.
</p>
<p>
    There is another way using shift operators:
</p>
<pre class="brush: cpp">
instruction = IB(M_MOV) &lt;&lt; OB::eff( EAX, 8 ) &lt;&lt; OB::reg( ECX );
</pre>
<p>
There is also a way to set prefixes and instruction hints, so let's set some of them:
</p>
<pre class="brush: cpp">
instruction = IB(M_MOV) &lt;&lt; IB::LOCK() &lt;&lt; IB::REP() &lt;&lt; IB::INDIRECT_PTR() 
                        &lt;&lt; IB::NEAR_PTR() &lt;&lt; OB::effb( EAX ) &lt;&lt; OB::reg( ECX );
</pre>
<p>
    Take into account one significant benefit of building instructions in this way. They can be built in a dynamic manner, you are able to provide every operand, address etc. using language variables. It's also possible to build instructions in more than one step using conditional statements. For instance such a construction is perfectly valid:
</p>
<pre class="brush: cpp">
IB builder = IB(M_JMP).off(0x404000);

if( isPositionIndependent ) {
    builder.set( OperandHint::RELATIVE_ADDRESSING() );
} else {
    builder.set( OperandHint::ABSOLUTE_ADDRESSING() );
}

Instruction instruction = builder.build();
</pre>
<p>
    Or even such one:
</p>
<pre class="brush: cpp">
IB builder = IB(M_MOV).reg(ECX);

Address address;
if( offset ) {
    address = Address::off( offset, FCML_DS_32 );
} else {
    address = Address::eff( EAX, FCML_DS_32 );
}

Instruction instruction = builder.op( address );
</pre>
<p>
    Where we build MOV instruction with the source operand being an offset of effective address with base register depending on the fact whether the absolute offset is set or not.
</p>
<p>
    To get back to the hints, there is also a possibility to set operand hints using the builder. The rule is simple here. All setting hints are added to the last operand which have been sent to the builder. So the following code:
</p>
<pre class="brush: cpp">
IB(M_RCL) &lt;&lt; OB::effb( 0x0000000000401007 ) &lt;&lt; IB::ABS() &lt;&lt; OB::imm( 3 );
</pre>
<p>
OR
</p>
<pre class="brush: cpp">
IB( M_RCL ).effb( 0x0000000000401007 ).abs().imm( 3 );
</pre>
<p>
can be interpreted as follows: "<span class="instruction">rcl byte ptr [abs 0000000000401007h],03h</span>".
</p>
<p>
    When the instruction is already built it can be still modified. For instance you are able to change the operands easily:
</p>
<pre class="brush: cpp">
instruction[0] = OB::reg( EDX );
</pre>

<h2 id="cpp-assembler">Assembler</h2>
<p>
    Using C++ assembler is as easy as using the native C version. All you have to do is to allocate a dialect, assembler context and then use them together to create and use an assembler instance. The whole process is shown in the following code:
</p>
<pre class="brush: cpp">
try {

   IntelDialect dialect;

   AssemblerContext ctx( EntryPoint::OM_32_BIT, 0x401000 );
   Assembler assembler( dialect );

   Instruction instruction = IB( M_MOV ) &lt;&lt; OB::reg( EAX ) &lt;&lt; OB::offd( 0x40302010 );
   
   AssemblerResult result;
   assembler.assemble( ctx, instruction, result );
   AssembledInstruction *chosenInstruction = result.getChosenInstruction();

} catch( BaseException &exc ) {
   std:out &lt;&lt; "Exception while assembling the code." &lt;&lt; std::endl;
}
</pre>
<p>
    The dialect and assembler instances are non copyable because they manage native FCML resources internally and in order to avoid complex resource management mechanisms and make the whole wrapper easy and consistent they cannot be copied like the other ordinal classes like <i><a href="api/classfcml_1_1Instruction.html">Instruction</a></i>, <i><a href="api/classfcml_1_1AssemblerResult.html">AssemblerResult</a></i> and so on. Just remember about the rule which was mentioned earlier, if you are able to copy anything it can be copied safely without making any dependencies between copied objects. You can be sure that a deep copy is made.
</p>
<p>
    <i><a href="api/classfcml_1_1AssemblerResult.html">AssemblerResult</a></i> consists of the same set of details as the plain <i><a href="api/structfcml__st__assembler__result.html">fcml_st_assembler_result</a></i> structure, so I'm pretty sure it doesn't have to be explained here. Anyway head over to the API section because there are a lot useful methods and operators which of course are not available in the C version.
There is one interesting method in the <i><a href="api/classfcml_1_1AssemblerResult.html">AssemblerResult</a></i> structure: <i><a href="api/classfcml_1_1AssemblerResult.html#a7f379a72d11c1f2b0771b7ced6bf84ca">getChosenInstruction</a></i>. This method is a special one, because as you might have noticed before it returns a pointer which is not so common in case of the whole FCML wrapper. It's probably the only place where such a convention is used, so be aware that it's a pointer to one of internally managed <i><a href="api/classfcml_1_1AssembledInstruction.html">AssembledInstruction</a></i> instances and as such they have the same life time.
</p>
<p>
    As you can see, exceptions are used if something fails by default. It's a global rule in case of FCML wrapping classes so bear in mind that you cannot avoid the usage of exceptions. Anyway in case of <i><a href="api/classfcml_1_1Assembler.html#af98559ff4f0d64931ad944eda874c8f0">"assemble()"</a></i> method (more about that in the disassembler chapter) you can disable exceptions by setting appropriate flag in the assembler configuration:
</p>
<pre class="brush: cpp">
assemblerContext.getConfig().setThrowExceptionOnError( false );
</pre>
<p>
    In such a case the <i><a href="api/classfcml_1_1Assembler.html#af98559ff4f0d64931ad944eda874c8f0">"assemble()"</a></i> method returns errors in the same way as <i><a href="api/fcml__assembler_8h.html#a232c49ae5936be24d990a5a012a63e78">fcml_fn_assemble</a></i> method does. This flag is set to true by default. 
</p>
<p>
    Remember that the constructor of the <i><a href="api/classfcml_1_1IntelDialect.html">IntelDialect</a></i> and <i><a href="api/classfcml_1_1GASDialect.html">GASDialect</a></i> can also throw an exception.
</p>
<p>
    See the API documentation I order to learn more about how <i><a href="api/classfcml_1_1AssembledInstruction.html">AssembledInstruction</a></i> and <i><a href="api/classfcml_1_1AssemblerResult.html">AssemblerResult</a></i> can be used.
</p>

<h2 id="cpp-multiline-assembler">Multiline assembler</h2>
<p>
    Multiline assembler has almost the same <a href="api/classfcml_1_1MultiPassAssembler.html">API</a> as the one-line assembler. The only difference is the source of the instructions and the way the result is returned. The following code example should be self-explainable:
</p>
<pre class="brush: cpp">

// Notice that it is an array of strings.
const fcml_string instructions[] = {
	"start:      mov ebx, 1",
	"loop_big:   inc ebx",
	"            cmp ebx, 10",
	"            je  finish",
	"loop_small: mov eax, 1",
	"increment:  inc eax",
	"            cmp eax, 10",
	"            je  finish_small",
	"            jmp increment",
	"finish_small:",
	"            jmp loop_big",
	"finish:     ret",
	NULL
};

…

try {

    IntelDialect dialect;
    MultiPassAssemblerContext ctx( EntryPoint::OM_32_BIT, 0x401000 );

    MultiPassAssembler assembler(dialect);

    MultiPassAssemblerResult result;
    assembler.assemble( ctx, instructions, result );

    CodeIterator it = result.getCodeIterator();
    while( it.hasNext() ) {
        cout &lt;&lt; "Next byte: " &lt;&lt; hex &lt;&lt; it.next() &lt;&lt; std::endl;
    }

} catch( BaseException &exc ) {
    cout &lt;&lt; "Exception while assembling the code." &lt;&lt; std::endl;
}
</pre>
<p>
    Notice the iterator here. Instead of iterating through the list of assembled instructions you can use this iterator to iterate through the whole assembled machine code without even touching the instructions. Remember that the iterator is a part of the <i><a href="api/classfcml_1_1MultiPassAssemblerResult.html">MultiPassAssemblerResult</a></i> instance and they have the same lifetime.
</p>
<p>
    Of course instructions are also available and can be accessed using <i><a href="api/classfcml_1_1MultiPassAssemblerResult.html#a0b372a77df80d58cb22b879c11adc52c">"getAssembledInstructions()"</a></i> method of the <i><a href="api/classfcml_1_1MultiPassAssemblerResult.html">MultiPassAssemblerResult</a></i> class.
</p>

<h2 id="cpp-stateful-assembler">Stateful assembler</h2>
<p>
    There is one more way to assemble code. It is a stateful assembler which can be used to assemble the code incrementally without even the care of the instruction pointer, code address incrementation etc. It is very easy to use and in fact it is also a very simple component. The following code shows an example usage:
</p>
<pre class="brush: cpp">
try {

    IntelDialect dialect;
    AssemblerContext ctx( EntryPoint::OM_64_BIT, 0x404ddc );

    Assembler assembler( dialect );

    StatefulAssembler statefulAssembler( assembler, ctx );

    statefulAssembler &lt;&lt; M_PUSH &lt;&lt; RBP;
    statefulAssembler &lt;&lt; M_MOV  &lt;&lt; RBP &lt;&lt; RSP;
    statefulAssembler &lt;&lt; M_SUB  &lt;&lt; RSP &lt;&lt; 0x20;

    CodeIterator it = statefulAssembler.getCodeIterator();
    while( it.hasNext() ) {
        cout &lt;&lt; "Next byte: " &lt;&lt; hex &lt;&lt; it.next() &lt;&lt; std::endl;
    }

} catch( BaseException &exc ) {
    cout &lt;&lt; "Exception while assembling the code." &lt;&lt; endl;
}
</pre>
<p>
    As you can see everything you are obliged to do in order to initialize it is to pass an assembler instance and an assembler context into the constructor. Then you can use dedicated methods or shift operators in order to assemble instructions one by one without doing anything else to achieve that. As you might have noticed using it is very similar to using the <i><a href="api/classfcml_1_1IB.html">fcml:IB</a></i> class described earlier and you are right. In fact it uses <i><a href="api/classfcml_1_1IB.html">fcml:IB</a></i> internally so the rules are very similar.
</p>
<p>
    There is one thing you have to be aware of using it. As you can see instructions are built mnemonic by mnemonic and operand by operand, but there is nothing like "now assemble the pending instruction". The assembling process is always invoked if there is a pending instruction in the buffer and the new instruction is being pushed into the assembler as a new mnemonic for instance. In such a case the pending instruction is firstly assembled and then the new one is being placed into the instruction builder. In case of the last instruction, the instruction is assembled lazily when you ask for the result by getting a code iterator or vector of assembled instructions. There is also a way to flush pending instruction on demand passing <i><a href="api/classfcml_1_1StatefulAssembler.html#ae3d658e83f2434f10886b7f314e988ee">StatefulAssembler::FLUSH()</a></i> to the builder using shift operators of calling <i><a href="api/classfcml_1_1StatefulAssembler.html#af27ec293a26e7a0caedab8557bd91ed1">"flush()"</a></i> method directly:
</p>
<pre class="brush: cpp">
statefulAssembler &lt;&lt; M_CALL &lt;&lt; OB::offq(0x41d719) &lt;&lt; StatefulAssembler::FLUSH();
</pre>
<p>
It is a quite important rule because such a lazily invoked assembling may fail and throw an exception. So you should be always prepared for it. 
</p>
<p>
There is also a way to assemble textual instructions after passing true as the third parameter to the <i><a href="api/classfcml_1_1StatefulAssembler.html">StatefulAssembler</a></i> constructor:
</p>
<pre class="brush: cpp">
try {

    IntelDialect dialect;
    AssemblerContext ctx( EntryPoint::OM_64_BIT, 0x404ddc, true );

    Assembler assembler(dialect);

    StatefulAssembler statefulAssembler(assembler, ctx);

    statefulAssembler.getParserConfig().setDisableSymbolsDeclaration(false);

    SymbolTable st;
    st.add( _FT("_start"), 0x41d719 );
    
    statefulAssembler.setSymbolTable( &st );

    statefulAssembler &lt;&lt; _FT( "push rbp" );
    statefulAssembler &lt;&lt; _FT( "mov rbp, rsp" );
    statefulAssembler &lt;&lt; _FT( "sub rsp, 0x20" );
    statefulAssembler &lt;&lt; _FT( "_label: mov dword [rbp-0x14], edi" );
    statefulAssembler &lt;&lt; _FT( "mov qword [rbp-0x20], rsi" );
    statefulAssembler &lt;&lt; _FT( "mov esi, 0x62d260" );
    statefulAssembler &lt;&lt; _FT( "mov edi, 0x41dbe8" );
    statefulAssembler &lt;&lt; _FT( "call _start" );

    Symbol symbol = st.get( _FT("_label") );

    CodeIterator it = statefulAssembler.getCodeIterator();
    while( it.hasNext() ) {
        cout &lt;&lt; "Next byte: " &lt;&lt; hex &lt;&lt; it.next() &lt;&lt; std::endl;
    }

} catch( BaseException &exc ) {
    cout &lt;&lt; "Exception while assembling the code." &lt;&lt; endl;
}
</pre>
<p>
    In such a case an internal parser instance is allocated and used to parse instructions just before they are passed to the assembler.
</p>
<p>
    This component is very simple so take a look at the source code to understand how it works in details.
</p>

<h2 id="cpp-disassembler">Disassembler</h2>
<p>
    The whole disassembler functionality is wrapped into <i><a href="api/classfcml_1_1Disassembler.html">Disassembler</a></i> class, which is a wrapper over the native <i><a href="api/fcml__disassembler_8h.html#a26d4fb7b2eae675eeaaadbd950881c07">fcml_fn_disassemble</a></i> function. The class itself is rather small and consists of 100 lines of code, but there are a lot of data containers which in majority of cases are counterparts to the structures that are used to return information about disassembled instructions and as such they are not described here in details. Head over to the <i><a href="api/annotated.html">API</a></i> documentation to master them. Looking at the API focus on the overloaded operands, because in some cases they can be really useful. Especially in case of common classes like Integer.
</p>
<p>
Ok, let's back to the disassembler. In order to prepare a working disassembler you have to allocate a dialect which has to be passed into the <i><a href="api/classfcml_1_1Disassembler.html#afff5a61c43919c2cc16dc1dfe294fca5">Disassembler</a></i> constructor and that's all as long as the constructor succeeded, but you have to be aware that it might fail if there is any problem with initialization of the FCML disassembler. Bear in mind that the majority of wrappers here use C functions in order to allocate needed resources. The disassembler is not an exception here and it uses <i><a href="api/fcml__disassembler_8h.html#adf09c06401a52542ce65739f8a441506">fcml_fn_disassembler_init</a></i> function which can also fail in some circumstances.
Having initialized a disassembler you only need a <i><a href="api/classfcml_1_1DisassemblerContext.html">DisassemberContext</a></i> and after initializing it you can start playing with the disassembler. The following code shows the disassembling process as a whole:
</p>
<pre class="brush: cpp">
try {
	Disassembler disassembler( dialect );

	DisassemblerContext ctx( code , sizeof( code ) );
	ctx.setIP(0x401000);
	ctx.setOperatingMode( EntryPoint::OM_32_BIT );

	DisassemblerResult result;
	disassembler.disassemble( ctx, result );

	const Instruction &instruction = result.getInstruction();

	fcml_cstring instructionMnemonic;

	Renderer renderer( dialect );
	RenderConfig config;
	renderer.render( config, result, instructionMnemonic );

	cout &lt;&lt;  instructionMnemonic;

} catch( BaseException &exc ) {
	cout &lt;&lt; "Disassembling failed." &lt;&lt; endl;
}
</pre>
<p>
    As you might notice the disassembled instruction is immediately rendered. The rendering process is so straightforward that it doesn't have dedicated chapter. Everything you have to do is to allocate <i><a href="api/classfcml_1_1Renderer.html">Renderer</a></i> instance for a dialect and pass a configuration into it.
<i><a href="api/classfcml_1_1DisassemblerResult.html">DisassemblerResult</a></i> consists of the same set of details as plain <i><a href="api/structfcml__st__disassembler__result.html">fcml_st_disassembler_result</a></i> structure, so I'm pretty sure it doesn't have to be explained here. Only one difference to the C version is one configuration flag responsible for controlling the error handling process. It can be used to disable exceptions for <i><a href="api/classfcml_1_1Disassembler.html#a142c0a01cc82fd47e60fb48060757c9b">"disassemble()"</a></i> and <i><a href="api/classfcml_1_1Renderer.html#aa3fa6db85019fe203134187e69864ab0">"render()"</a></i> methods. It is a consistent rule that renderer, parser, assembler and disassembler can return classic <i><a href="api/fcml__errors_8h.html#a5dc52a6ee90a57e58a0760296b0c36e3">fcml_ceh_error</a></i> error code instead of firing exceptions, however you should bear in mind that their constructors throw exceptions in case of any problem and as such you are not able to avoid exceptions at all.
</p>
<p>
    As it was pointed out in the first chapter every object can be safely copied and it doesn't need any special care, so you can for example copy every assembled instruction into a vector and you do not have to deal with any allocation related issues.
</p>

<h2 id="cpp-stateful-disassembler">Stateful disassembler</h2>
<p>
    The stateful disassembler automates the process of disassembling instructions one by one. It consist of <i><a href="api/classfcml_1_1DisassemblerContext.html">DisassemberContext</a></i> and the <i><a href="api/classfcml_1_1Disassembler.html#afff5a61c43919c2cc16dc1dfe294fca5">Disassembler</a></i> itself and is a kind of mediator which controls the whole process. The following code shows how to initialize stateful disassembler and dissemble four instructions in a row:
</p>
<pre class="brush: cpp">
try {

    GASDialect dialect;

    Disassembler disassembler( dialect );

    DisassemblerContext ctx( code_buffer , sizeof( code_buffer ) );
    ctx.setIP(0x404ddc);
    ctx.setOperatingMode(EntryPoint::OM_64_BIT);

    StatefulDisassembler disas( disassembler, ctx, true );

    Instruction instruction;

    // Disassemble four instructions oner by one.
    disas &gt;&gt; instruction;
    disas &gt;&gt; instruction;
    disas &gt;&gt; instruction;
    disas &gt;&gt; instruction;

} catch( BaseException &exc ) {
    cout &lt;&lt; "Exception while disassembling the code." &lt;&lt; endl;
}
</pre>
<p>
You have to take into account that you cannot avoid exceptions using the stateful disassembler. It is a reasonable decision, because as you might have noticed, in some cases there are even no ways to return classic error codes. 
</p>
<p>
    The component itself is located in the <i><a href="api/fcml__stateful__disassembler_8hpp.html">fcml_stateful_disassembler.hpp</a></i> header file. If you have any questions do not hesitate to take a look at the implementation. The component is really simple and consists of only about 200 lines of code.
</p>
<p>
    Mind you that every class used is allocated on the stack. It is one of the global rules. You can allocate everything without the use of the new operator. There are event classes which cannot be allocated using the new operator at all, like the exceptions.
</p>

<h1 id="examples">Examples</h1>
<p>
	The following sections describe three example applications available for the FCML library.
</p>

<h2 id="examples-fcml-asm">fcml-asm</h2>
<p>
	It is a simple console application built during the main build process. It is an one-line assembler which can be used to assembler a piece of machine code and print the assembled instruction to the console. This application is not installed in the system when "<tt>make install</tt>" is called, so in order to use it go to the "example/fcml-asm" directory when the build process is finished. This example application is not available for Visual Studio build.
</p>
<p>
	Example usage:
</p>
<pre>
tas@tas ~/git/fcml/example/fcml-asm $ <b>./fcml_asm -m32 -ip 0x4001000 "add eax,1"</b>
Number of assembled instructions: 3
Instruction: 1 
 Code: 83c001 
 Code length: 3 
Instruction: 2 
 Code: 81c001000000 
 Code length: 6 
Instruction: 3 
 Code: 0501000000 
 Code length: 5 
Best instruction chosen by the assembler: 1 
</pre>
<p>
	In order to get information about all supported options type "<tt>./fcml-asm –help</tt>".
</p>

<h2 id="examples-fcml-disasm">fcml-disasm</h2>
<p>
	It is an one-instruction disassembler (built as a part of the main build process) which can be used to disassemble a piece of machine code and print the disassembled instruction to the console. This application is not installed in the system when "<tt>make install</tt>" is called, so in order to use it go to the "example/fcml-disasm" directory when the build process is finished. This example application is not available for Visual Studio build.
</p>
<p>
	Example usage:
</p>
<pre>
tas@tas ~/git/fcml/example/fcml-disasm $ <b>./fcml_disasm -m32 -ip 0x4001000 0x678316010203</b>
Basic information: 
 Disassembled instruction: adc dword ptr [0201h],3 
 Mnemonic: adc 
 Instruction hints: FCML_HINT_NEAR_POINTER 
 Number of operands: 2 
  Operands: 
   Operand: 1 
    Type: FCML_OT_ADDRESS 
    Address form: Offset. 
    Segment register: ds (default: true) 
    Size operator: 32 
    Offset: 
     Size: 16 
     Signed: true 
     Value: 0x0201 
   Operand: 2 
    Type: FCML_OT_IMMEDIATE 
    Signed: true 
    Size: 32 
    Value: 0x00000003 
Details: 
 Instruction code: 0x678316010203 
 Instruction code length: 6 
 Pseudo-op: false 
 Shortcut: false 
 ModR/M details: 
  Is RIP: false 
  ModR/M byte: 0x16 
 Prefixes details: 
  Prefixes size in bytes: 1 
  Number of available prefixes: 1 
  Available prefixes (flags): 
  Prefixes fields: 
  Available prefixes (details): 
   Byte: 0x67, Type FCML_PT_GROUP_4, Mandatory: false, XOP/VEX bytes: 0x00, 0x00. 
 Operands details: 
  Operand: 1 
   Access mode: FCML_AM_READ FCML_AM_WRITE 
  Operand: 2 
   Access mode: FCML_AM_READ 
</pre>
<p>
	In order to get information about all supported options type "<tt>./fcml-disasm –help</tt>".
</p>

<h2 id="examples-hsdis">hdis</h2>
<p>
	It is a fully functional disassembler for Java just-in-time compiler. It can be registered inside the chosen Java process in order to print the whole native code generated by JIT. As opposed to the examples above it does not take part in the main build process, so in order to build it you have to go to the "exampes/hdis" directory and type: "<tt>make</tt>". After the build process is finished you have to go to the ".libs" directory where the shared library was built. You will find something like: "libsdis.so.0.0.0" in there. It is the built disassembler. This project is also available for the Visual Studio build and in case of the Visual Studio all you need to do is to click build :)
</p>
<div class="notice-box">
Do not use MinGW/Cygwin to build this example if you do not know how to build it correctly, because by default FCML is not configured to build the library in the appropriate way using these compilers (Mentioned problem with symbols.). Remember that there are pre-built binaries in the distribution archive.
</div>
<p>
	The next thing to do is to install the library in the correct place. The following table shows the name of the library it should be renamed to and the place where it has to be copied. For the VS pre-built binaries the renaming is not necessary because libraries are available with the correct name.
</p>
<div class="table-responsive">
	<table class="table table-bordered fcml-table">
		<thead>
			<tr>
				<th>System/Architecture</th>
				<th>Library name</th>
				<th>Destination</th>
			</tr>
		</thead>
		<tbody>
			<tr>
				<td>GNU/Linux-x86</td>
				<td>hsdis-i386.so</td>
				<td>${JAVA_HOME}/jre/lib/amd64</td>
			</tr>
			<tr>
				<td>GNU/Linux-x86_64</td>
				<td>hsdis-amd64.so</td>
				<td>${JAVA_HOME}/jre/lib/i386</td>
			</tr>
			<tr>
				<td>Windows-x86</td>
				<td>hsdis-i386.dll</td>
				<td>${JAVA_HOME}\bin\server\hsdis-i386.dll</td>
			</tr>
			<tr>
				<td>Windows-x86_64</td>
				<td>hsdis-amd64.dll</td>
				<td>${JAVA_HOME}\bin\server\hsdis-amd64.dll</td>
			</tr>
		</tbody>
	</table>
</div>
<p>
	In case of Windows, the Java process looks for the library in the same directory where the used jvm.dll is located. So you can also copy the library into all places where different versions of the jvm.dll are located if you do not know which one is being used by the Java process.
</p>
<p>
	Then you have to run Java with appropriate parameters in order to enable the installed disassembler, for instance:
</p>
<pre>
java -XX:+UnlockDiagnosticVMOptions \
     -XX:+PrintAssembly \
     -XX:+LogCompilation \
     -XX:PrintAssemblyOptions=intel,mpad=10,cpad=10,code \
     -jar fcml-test.jar
</pre>
<p>
	In the result you should see something like this:
</p>
<pre>
e:\><b>java -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -XX:+LogCompilation -XX:PrintAssemblyOptions=intel,mpad=10,cpad=10,code -jar fcml-test.jar</b> 
Java HotSpot(TM) 64-Bit Server VM warning: PrintAssembly is enabled; turning on DebugNonSafepoints to gain additional output
Loaded disassembler from C:\Program Files\Java\jre7\bin\server\hsdis-amd64.dll
Decoding compiled method 0x000000000212a210:
Code:
RIP: 0x212a340 Code size: 0x00000158
[Disassembling for mach='amd64']
[Entry Point]
[Constants]
  # {method} 'hashCode' '()I' in 'java/lang/String'
  #           [sp+0x30]  (sp of caller)
  0x000000000212a340: 448b5208            mov       r10d,dword ptr [rdx+8h]
  0x000000000212a344: 493bc2              cmp       rax,r10
  0x000000000212a347: 0f8513d7fcff        jne       20f7a60h
                                                ;   {runtime_call}
  0x000000000212a34d: 666690              nop
[Verified Entry Point]
  0x000000000212a350: 89842400a0ffff      mov       dword ptr [rsp+0ffffffffffffa000h],eax
  0x000000000212a357: 55                  push      rbp
  0x000000000212a358: 4883ec20            sub       rsp,20h
                                                ;*synchronization entry
                                                ; - java.lang.String::hashCode@-1
  0x000000000212a35c: 4c8bea              mov       r13,rdx
  0x000000000212a35f: 8b4210              mov       eax,dword ptr [rdx+10h]
                                                ;*getfield hash
                                                ; - java.lang.String::hashCode@1
  0x000000000212a362: 85c0                test      eax,eax
  0x000000000212a364: 0f85da000000        jne       212a444h 
</pre>
<p>
	The following assembly options are supported by hsdis:
</p>
<dl class="dl-horizontal">
	<dt>code</dt>
	<dd>Print the machine code before the mnemonic.</dd>
	<dt>intel</dt>
	<dd>Use the Intel syntax.</dd>
	<dt>gas</dt>
	<dd>Use the AT&amp;T assembler syntax (GNU assembler compatible).</dd>
	<dt>dec</dt>
	<dd>Prints IMM and displacement as decimal values.</dd>
	<dt>mpad=XX</dt>
	<dd>Padding for the mnemonic part of the instruction.</dd>
	<dt>cpad=XX</dt>
	<dd>Padding for the machine code.</dd>
	<dt>seg</dt>
	<dd>Shows the default segment registers.</dd>
	<dt>zeros</dt>
	<dd>Show leading zeros in case of HEX values.</dd>
</dl>

</div>
		   
		   <div id="table_of_content" class="col-sm-3 toc-sidebar">
				<ul class="nav toc-nav nav-stacked affix-top toc-numbered" data-spy="affix" data-offset-top="40">
					<li><a href="#what_is">What is FCML</a></li>
					<li><a href="#features">Features</a></li>
					<li><a href="#license">License</a></li>
					<li><a href="#installation">Installation</a>
						<ul class="nav">
							<li><a href="#installation-downloading">Downloading</a></li>
							<li><a href="#installation-gnu_linux">GNU/Linux</a></li>
							<li><a href="#installation-windows">Windows</a>
								<ul class="nav">
									<li><a href="#installation-windows-mingw">MinGW</a></li>
									<li><a href="#installation-windows-vs">Visual Studio</a></li>
								</ul>	
							</li>
						</ul>
					</li>
					<li><a href="#quick_start">Quick Start</a>
						<ul class="nav">
							<li><a href="#quick_start-assembler">Assembler</a></li>
							<li><a href="#quick_start-disassembler">Disassembler</a></li>
						</ul>
					</li>
					<li><a href="#manual">Manual</a>
						<ul class="nav">
							<li><a href="#generic_instruction_model">Generic instruction model</a>
								<ul class="nav">
									<li><a href="#prefixes">Prefixes</a></li>
									<li><a href="#instruction_level_hints">Instruction level hints</a></li>
									<li><a href="#mnemonic">Mnemonic</a></li>
									<li><a href="#conditional_instructions">Conditional instructions</a></li>
									<li><a href="#operands">Operands</a>
										<ul class="nav">
											<li><a href="#op-hints">Hints</a></li>
											<li><a href="#op-immediate">Immediate value operand</a></li>
											<li><a href="#op-far-pointer">Far pointer operand</a></li>
											<li><a href="#op-address-operand">Address operand</a></li>
											<li><a href="#op-register-operand">Register operand</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#un-entry-point">Understanding entry point</a></li>
							<li><a href="#dialects">Dialects</a>
								<ul class="nav">
									<li><a href="#dialects-initializing-intel">Initializing Intel dialect</a></li>
									<li><a href="#dialects-initializing-gas">Initializing AT&amp;T (GAS) dialect</a></li>
									<li><a href="#dialects-disposing">Disposing dialect</a></li>
									<li><a href="#dialects-differences">Important differences between dialects</a>
										<ul class="nav">
											<li><a href="#dialects-difs-far-pointers">Far pointers</a></li>
											<li><a href="#dialects-difs-relative-addresses">Relative addresses</a></li>
											<li><a href="#dialects-dir-ind-addresses">Direct and indirect addresses</a>
												<ul class="nav">
													<li><a href="#dialects-dir-ind-addresses-intel">Intel dialect</a></li>
													<li><a href="#dialects-dir-ind-addresses-gas">AT&amp;T dialect</a></li>
												</ul>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#data-types">Data types</a></li>
							<li><a href="#error-handling">Error handling</a></li>
							<li><a href="#configuring-environment">Configuring environment</a></li>
							<li><a href="#pseudo-operations">Pseudo operations</a></li>
							<li><a href="#symbols">Symbols</a></li>
							<li><a href="#assembler">Assembler</a>
								<ul class="nav">
									<li><a href="#assembler-initialization">Initializing assembler instance</a></li>
									<li><a href="#assembler-assembling">Assembling generic instruction model</a>
										<ul class="nav">
											<li><a href="#asm-ctx">Assembler context</a></li>
											<li><a href="#asm-optimizers">Optimizers</a></li>
											<li><a href="#asm-choosers">Instruction choosers</a></li>
											<li><a href="#asm-result">Preparing assembler result</a></li>
											<li><a href="#asm-invoke">Invoking assembler</a></li>
										</ul>
									</li>
									<li><a href="#assembler-multi-pass">Multi pass assembler</a></li>
								</ul>
							</li>
							<li><a href="#parser">Parser</a>
								<ul class="nav">
									<li><a href="#parser-init-invoke">Initialization and parsing</a></li>
									<li><a href="#parser-how-it-works">How parser works</a></li>
									<li><a href="#parser-common-rules">Common rules</a>
										<ul class="nav">
											<li><a href="#parser-common-numeric">Representation of numeric values</a></li>
											<li><a href="#parser-common-expressions">Expressions handling</a></li>
										</ul>
									</li>
									<li><a href="#parser-intel">Intel parser</a>
										<ul class="nav">
											<li><a href="#parser-intel-numeric">Numeric values</a></li>
											<li><a href="#parser-intel-registers-expressions">Registers</a></li>
											<li><a href="#parser-intel-size-operators">Size operators</a></li>
											<li><a href="#parser-intel-prefixes">Prefixes</a></li>
											<li><a href="#parser-intel-hints">Hints</a></li>
										</ul>
									</li>
									<li><a href="#parser-gas">AT&amp;T parser</a>
										<ul class="nav">
											<li><a href="#parser-gas-numeric">Numeric values</a></li>
											<li><a href="#parser-gas-registers-expressions">Registers</a></li>
											<li><a href="#parser-gas-size-operators">Size operators</a></li>
											<li><a href="#parser-gas-prefixes">Prefixes</a></li>
											<li><a href="#parser-gas-hints">Hints</a></li>
										</ul>
									</li>
								</ul>
							</li>
							<li><a href="#disassembler">Disassembler</a>
								<ul class="nav">
									<li><a href="#disassembler-init">Initializing disassembler instance</a></li>
									<li><a href="#disassembler-result">Initializing disassembler result</a></li>
									<li><a href="#disassembler-disassembling">Disassembling machine code</a></li>
									<li><a href="#disassembler-analyse">Analysing instruction details</a>
										<ul class="nav">
											<li><a href="#disassembler-analyse-shortcuts">Shortcuts</a></li>
											<li><a href="#disassembler-analyse-machine-code">Instruction machine code</a></li>
											<li><a href="#disassembler-analyse-prefixes">Prefixes</a></li>
											<li><a href="#disassembler-analyse-operand-details">Operand details</a></li>
											<li><a href="#disassembler-analyse-modrm">Details about ModR/M field</a></li>
											<li><a href="#disassembler-analyse-fields">Instruction code and opcode fields</a></li>
											<li><a href="#disassembler-instruction-groups">Instruction groups</a></li>
										</ul>
									</li>
									<li><a href="#disassembler-free">Freeing resources</a></li>
								</ul>
							</li>
							<li><a href="#instruction-renderer">Instruction renderer</a></li>
						</ul>
					</li>
					<li><a href="#cpp-wrapper">CPP Wrapper</a>
						<ul class="nav">
							<li><a href="#cpp-mnemonics">Mnemonics</a></li>
							<li><a href="#cpp-common-types">Common types</a>
								<ul class="nav">
									<li><a href="#cpp-common-types-cpp-character-types">Character types</a></li>
									<li><a href="#cpp-common-types-cpp-entry-point-class">EntryPoint class</a></li>
									<li><a href="#cpp-common-types-cpp-integer-class">Integer class</a></li>
									<li><a href="#cpp-common-types-cpp-register-class">Register class</a></li>
								</ul>
							</li>
							<li><a href="#cpp-generic-instruction-model">Generic instruction model</a>
								<ul class="nav">
									<li><a href="#cpp-generic-instruction-model-cpp-far-pointer">Far pointer</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-segment-selector">Segment selector</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-effective-address">Effective address</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-addresses">Addresses</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-conditions">Conditions</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-operands">Operands</a></li>
									<li><a href="#cpp-generic-instruction-model-cpp-instructions">Instructions</a></li>
								</ul>
							</li>
							<li><a href="#cpp-assembler">Assembler</a></li>
							<li><a href="#cpp-multiline-assembler">Multiline assembler</a></li>
							<li><a href="#cpp-stateful-assembler">Stateful assembler</a></li>
							<li><a href="#cpp-disassembler">Disassembler</a></li>
							<li><a href="#cpp-stateful-disassembler">Stateful disassembler</a></li>
						</ul>
					</li>
					<li><a href="#example">Examples</a>
						<ul class="nav">
							<li><a href="#examples-fcml-asm">fcml-asm</a></li>
							<li><a href="#examples-fcml-disasm">fcml-disasm</a></li>
							<li><a href="#examples-hsdis">hdis</a></li>
						</ul>
					</li>
				</ul>
			</div>
		   
		</div>
	</article>
	
	<!-- Footer -->

	<footer class="footer clearfix">
		Copyright &copy; 2010-2020 Sławomir Wojtasiak<br>
		All rights reserved
	</footer>
	
    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<script type="text/javascript" src="js/sh/shCore.js"></script>
	<script type="text/javascript" src="js/sh/shBrushCpp.js"></script>
	<script type="text/javascript">
     SyntaxHighlighter.all()
	</script>
    <script src="js/bootstrap.js"></script> 
  </body>
</html>
